/*
 *  Source machine generated by GadToolsBox V2.0b
 *  which is (c) Copyright 1991-1993 Jaba Development
 *
 *  GUI Designed by : Jan Erik Olausen
 */

// 	oldFunc = SetFunction (library, funcOffset, funcEntry)
//     	D0		                A1       A0.W	       D0


#include <JEO:JEO.h>
#include <ctype.h>
#include <exec/memory.h>
#include <exec/execbase.h>
#include <proto/dos.h>
#include <proto/intuition.h>
#include <proto/graphics.h>
#include <proto/gadtools.h>
#include <libraries/reqtools.h>
#include <proto/reqtools.h>
#include "VE_Prototypes.h"
#include <JEO:raw.h>
#include "VE_Monitor.h"
#include <intuition/gadgetclass.h>
#include "PatchWindow.h"

VOID OutPutAddress (ULONG address, BOOL mode);
ULONG CheckMemAddress (ULONG address);
VOID MonitorAll (BOOL status);

UBYTE line_nr, page_nr;

struct RastPort *mm_rp;

#define MM_X	12
UBYTE dump;
ULONG original_address, top_address;

struct Window         *MonitorWnd = NULL;
struct Gadget         *MonitorGList = NULL;
struct Gadget         *MonitorGadgets[7];
UWORD                  MonitorLeft = 0;
UWORD                  MonitorTop = 30;
UWORD                  MonitorWidth = 632;
UWORD                  MonitorHeight = 183;
UBYTE                 *MonitorWdt = NULL;

UBYTE *MM_DUMP0Labels[] = {
	(UBYTE *)"Hex dump",
	(UBYTE *)"ASCII dump",
	(UBYTE *)"Disassemble",
	NULL };

UWORD MonitorGTypes[] = {
	CYCLE_KIND,
	BUTTON_KIND,
	BUTTON_KIND,
	BUTTON_KIND,
	BUTTON_KIND,
	BUTTON_KIND,
	BUTTON_KIND
};

struct NewGadget MonitorNGad[] = {
	  3, 150, 114, 15, NULL, NULL, GD_MM_DUMP, 0, NULL, NULL,
	147, 150,  66, 15, (UBYTE *)"Line -", NULL, GD_MM_LINE_MINUS, PLACETEXT_IN, NULL, NULL,
	216, 150,  66, 15, (UBYTE *)"Line +", NULL, GD_MM_LINE_PLUS, PLACETEXT_IN, NULL, NULL,
	294, 150,  66, 15, (UBYTE *)"Page -", NULL, GD_MM_PAGE_MINUS, PLACETEXT_IN, NULL, NULL,
	363, 150,  66, 15, (UBYTE *)"Page +", NULL, GD_MM_PAGE_PLUS, PLACETEXT_IN, NULL, NULL,
	451, 150,  75, 15, (UBYTE *)"Home", NULL, GD_MM_ADDRESS, PLACETEXT_IN, NULL, NULL,
	548, 150,  66, 15, (UBYTE *)"Exit", NULL, GD_MM_EXIT, PLACETEXT_IN, NULL, NULL
};

ULONG MonitorGTags[] = {
	(GTCY_Labels), (ULONG)&MM_DUMP0Labels[ 0 ], (TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE)
};

void MonitorRender( void )
{
	UWORD		offx, offy;

	offx = MonitorWnd->BorderLeft;
	offy = MonitorWnd->BorderTop;


	DrawBevelBox( MonitorWnd->RPort, offx + 1, offy + -8, 612, 15, GT_VisualInfo, VisualInfo, GTBB_Recessed, TRUE, TAG_DONE );
	DrawBevelBox( MonitorWnd->RPort, offx + 2, offy + 11, 612, 134, GT_VisualInfo, VisualInfo, GTBB_Recessed, TRUE, TAG_DONE );
}

int OpenMonitorWindow( void )
{
	struct NewGadget	ng;
	struct Gadget	*g;
	UWORD		lc, tc;
	UWORD		offx = Scr->WBorLeft, offy = Scr->WBorTop + Scr->RastPort.TxHeight + 1;

	if ( ! ( g = CreateContext( &MonitorGList )))
		return( 1L );

	for( lc = 0, tc = 0; lc < Monitor_CNT; lc++ ) {

		CopyMem((char * )&MonitorNGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

		ng.ng_VisualInfo = VisualInfo;
		ng.ng_TextAttr   = &topaz8;
		ng.ng_LeftEdge  += offx;
		ng.ng_TopEdge   += offy;

		MonitorGadgets[ lc ] = g = CreateGadgetA((ULONG)MonitorGTypes[ lc ], g, &ng, ( struct TagItem * )&MonitorGTags[ tc ] );

		while( MonitorGTags[ tc ] ) tc += 2;
		tc++;

		if ( NOT g )
			return( 2L );
	}

	if ( ! ( MonitorWnd = OpenWindowTags( NULL,
				WA_Left,	MonitorLeft,
				WA_Top,		MonitorTop,
				WA_Width,	MonitorWidth,
				WA_Height,	MonitorHeight + offy,
				WA_IDCMP,	CYCLEIDCMP|BUTTONIDCMP|IDCMP_CLOSEWINDOW|IDCMP_ACTIVEWINDOW|IDCMP_REFRESHWINDOW|IDCMP_RAWKEY,
				WA_Flags,	WFLG_GIMMEZEROZERO|WFLG_DRAGBAR|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH|WFLG_ACTIVATE|WFLG_RMBTRAP,
				WA_Gadgets,	MonitorGList,
				WA_CustomScreen, Scr,
				TAG_DONE )))
	return( 4L );

	GT_RefreshWindow( MonitorWnd, NULL );

	MonitorRender();

	return( 0L );
}

void CloseMonitorWindow( void )
{
	if ( MonitorWnd        ) {
		CloseWindow( MonitorWnd );
		MonitorWnd = NULL;
	}

	if ( MonitorGList      ) {
		FreeGadgets( MonitorGList );
		MonitorGList = NULL;
	}
}

// *****************************************************************************

ULONG mem_start, mem_end;

VOID LineDown (VOID)
{
	if (dump == 0)
	{
		top_address += 16;	// HEX
		if (top_address > mem_end)
			top_address = mem_start + (top_address - mem_end - 1);
	}
	else if (dump == 1)
	{
		top_address += 64;	// ASCII
		if (top_address > mem_end)
			top_address = mem_start + (top_address - mem_end - 1);
	}
	else if (dump == 2)
	{
		top_address += line_nr;	// Disassemble
		if (top_address > mem_end)
			top_address = mem_start + (top_address - mem_end - 1);
	}
	OutPutAddress (top_address, dump);	// Start with hex always
}

VOID LineUp (VOID)
{
	if (dump == 0)
	{
		top_address -= 16;	// HEX
		if (top_address < mem_start)
			top_address = mem_end - (mem_start - top_address - 1);
	}
	else if (dump == 1)
	{
		top_address -= 64;	// ASCII
		if (top_address < mem_start)
			top_address = mem_end - (mem_start - top_address - 1);
	}
	else if (dump == 2)
	{
		top_address -= 2;	// Disassemble
		if (top_address < mem_start)
			top_address = mem_end - (mem_start - top_address - 1);
	}
	OutPutAddress (top_address, dump);	// Start with hex always
}

VOID PageUp (VOID)
{
	if (dump == 0)
	{
		top_address -= (16 * 16);	// HEX
		if (top_address < mem_start)
			top_address = mem_end - (mem_start - top_address - 1);
	}
	else if (dump == 1)
	{
		top_address -= (16 * 64);	// ASCII
		if (top_address < mem_start)
			top_address = mem_end - (mem_start - top_address - 1);
	}
	OutPutAddress (top_address, dump);	// Start with hex always
}

VOID PageDown (VOID)
{
	if (dump == 0)
	{
		top_address += (16 * 16);	// HEX
		if (top_address > mem_end)
			top_address = mem_start + (top_address - mem_end - 1);
	}
	else if (dump == 1)
	{
		top_address += (16 * 64);	// ASCII
		if (top_address > mem_end)
			top_address = mem_start + (top_address - mem_end - 1);
	}
	OutPutAddress (top_address, dump);	// Start with hex always
}

VOID Home (VOID)
{
	top_address = original_address;
	OutPutAddress (top_address, dump);
/*
	ULONG address;
	char Buf[9];
	
	sprintf (Buf, "%08lX", original_address);
	MonitorAll (OFF);
	if (rtGetString (Buf, 8, "Enter address:", NULL, RT_ReqPos, REQPOS_CENTERSCR, RT_TextAttr, &topaz8, TAG_END))
	{
		top_address = strtoul (Buf, NULL, 16);
		OutPutAddress (top_address, dump);	// Start with hex always
	}
	MonitorAll (ON);
*/
}

VOID MonitorInitGadget (UWORD num, LONG tagtype, LONG tagvalue)
{
  GT_SetGadgetAttrs (MonitorGadgets[num], MonitorWnd, NULL, tagtype, tagvalue, TAG_DONE);
}

BOOL HandleMonitorIDCMP (VOID)
{
	struct IntuiMessage	*m;
	struct IntuiMessage	tmpmsg;
  BOOL ret = TRUE;
  BOOL disable_gadgets;

	while (m = GT_GetIMsg (MonitorWnd->UserPort))
	{
		CopyMem ((char *)m, (char *)&tmpmsg, (long)sizeof(struct IntuiMessage));
		GT_ReplyIMsg (m);
		switch (tmpmsg.Class)
		{
/*
			case IDCMP_DISKINSERTED:
				DiskInserted ();
				All (OFF);
				Status (GLS (&L_PLEASE_WAIT));
				break;
			case IDCMP_DISKREMOVED:
				DiskRemoved ();
				Status (GLS (&L_PLEASE_WAIT));
				break;
*/
			case	IDCMP_RAWKEY:
			{
				switch (tmpmsg.Code)
				{
					case ESC: ret = FALSE; break;

					case DOWN_ARR:	LineDown ();	break;
					case UP_ARR:		LineUp ();		break;
					case RIGHT_ARR: PageDown ();	break;
					case LEFT_ARR:	PageUp ();		break;

					case NUMERIC2:	LineDown ();	break;
					case NUMERIC8:	LineUp ();		break;
					case NUMERIC3:	PageDown ();	break;
					case NUMERIC9:	PageUp ();		break;
					case NUMERIC7:	Home ();			break;
				}
				break;
			}
			case	IDCMP_CLOSEWINDOW:
			{
				ret = FALSE;
				break;
			}
			case	IDCMP_GADGETUP:
			{
			  struct Gadget *gadget;
				UWORD nr;

			  gadget = (struct Gadget *)tmpmsg.IAddress;
				nr = gadget->GadgetID;

			  switch (nr)
			  {
					case GD_MM_EXIT:
					{
						ret = FALSE;
						break;
					}
					case GD_MM_DUMP:
					{
						dump++;
						if (dump > 2)
							dump = 0;
						if (dump == 2)	// Disassemble
						  disable_gadgets = TRUE;
						else
						  disable_gadgets = FALSE;

					  MonitorInitGadget (GD_MM_PAGE_MINUS, GA_Disabled, disable_gadgets);
					  MonitorInitGadget (GD_MM_PAGE_PLUS, GA_Disabled, disable_gadgets);

						OutPutAddress (top_address, dump);	// Start with hex always
						break;
					}
					case GD_MM_LINE_MINUS: LineUp ();   break;
					case GD_MM_LINE_PLUS:  LineDown ();	break;
					case GD_MM_PAGE_MINUS: PageUp ();		break;
					case GD_MM_PAGE_PLUS:	 PageDown ();	break;
					case GD_MM_ADDRESS:		 Home (); break;
				}
				break;
			}
		}
	}
	return (ret);
}

char Formats[][30] =
{
	"%s",										// 0
	"(%s)",									// 1
	"(%s)+",								// 2
	"-(%s)",								// 3
	"#$%08lX,(-$%04lX,%s)",	// 4
	"#$%08lX,($%04lX,%s)",	// 5
	"#$%08lX,%s",						// 6
	"%s,$%08lX",						// 7
	"(%s),$%08lX",					// 8
	"(%s)+,$%08lX",					// 9
	"-(%s),$%08lX",					// 10
	"$%08lX,%s",						// 11
	"$%08lX",								// 12
	"(-$%04lX,%s)",					// 13
	"($%04lX,%s)",					// 14
	"#$%02lX,($%04lX,%s)",	// 15
	"$%08lX,-(%s)",					// 16
	",($%04lX,%s)",					// 17
	"$%04lX,%s",						// 18
	"$%04lX%s,%s",					// 19
	"($%08lX,PC),-(%s)",		// 20
	"($%08lX,PC)",					// 21
	"#$%04lX,%s",						// 22
	"#$%02lX,%s",						// 23
	"#$%02lX,(%s)",					// 24
	"#$%02lX,(%s)+",				// 25
	"#$%02lX,-(%s)",				// 26
	"#$%04lX,(%s)",					// 27
	"#$%04lX,(%s)+",				// 28
	"#$%04lX,-(%s)",				// 29
	"#$%08lX,(%s)",					// 30
	"#$%08lX,(%s)+",				// 31
	"#$%08lX,-(%s)",				// 32
	"($%04lX,%s),%s",				// 33
	"(%s),%s",							// 34
	"%s,(%s)",							// 35
	"#$%04lX",							// 36
	"#$%02lX",							// 37
	"#%ld,%s",							// 38
	"CCR,%s",								// 39
	"CCR,(%s)+",						// 40
	"CCR,-(%s)",						// 41
	"(%s)+,%s",							// 42
	"%s,-(%s)",							// 43
	"%s,%s",								// 44
	"%s,($%04lX,%s)",				// 45
	"%s,#$%04lX",						// 46
	"($%08lX,PC),%s",				// 47
	"#%ld,(-$%04lX,%s)",		// 48
	"#%ld,($%04lX,%s)",			// 49
	"($%04lX,%s),($%04lX,%s)", // 50
	"-(%s),-(%s)",					// 51
	"%s,(%s)+",							// 52
	"#$%04lX,%s",						// 53
	"#%ld,$%08lX",					// 54
	"$%08lX,"								// 55
};

char C_020[] = "68020++";
char C_030[] = "68030++";
char C_040[] = "68040++";
char C_060[] = "68060++";

char B[] = ".B";
char W[] = ".W";
char L[] = ".L";
char Q[] = "Q";
char A[] = "A";
char I[] = "I";
char X[] = "X";

char Commands[][6] =
{
	"MOVE",
	"MOVEM",
	"BTST",
	"BSET",
	"LINK",
	"UNLK",
	"CMP",
	"TST",
	"CLR",
	"AND",
	"OR",
	"JSR",
	"JMP",
	"ASL",
	"EXT",
	"NEG",
	"DBF",
	"LSR",
	"LSL",
	"ASR",
	"MULU",
	"DIVU",
	"MULS",
	"DIVS",
	"ADD",
	"SUB",
	"LEA",
	"PEA",
	"ST",
	"SWAP",
	"TRAPF"
};

enum
{
	C_MOVE = 0,
	C_MOVEM,
	C_BTST,
	C_BSET,
	C_LINK,
	C_UNLK,
	C_CMP,
	C_TST,
	C_CLR,
	C_AND,
	C_OR,
	C_JSR,
	C_JMP,
	C_ASL,
	C_EXT,
	C_NEG,
	C_DBF,
	C_LSR,
	C_LSL,
	C_ASR,
	C_MULU,
	C_DIVU,
	C_MULS,
	C_DIVS,
	C_ADD,
	C_SUB,
	C_LEA,
	C_PEA,
	C_ST,
	C_SWAP,
	C_TRAPF
};

#define C_B 0x0001
#define C_W 0x0002
#define C_L 0x0004
#define C_A1	 0x0010
#define C_I1	 0x0020
#define C_Q1	 0x0040
#define C_X1	 0x0080

VOID MakeCode (char *Code, UBYTE commands, UBYTE ext) 
{
	strcpy (Code, Commands[commands]);
	if (ext & C_Q1)
		strcat (Code, Q);
	else if (ext & C_I1)
		strcat (Code, I);
	else if (ext & C_A1)
		strcat (Code, A);
	else if (ext & C_X1)
		strcat (Code, X);

	if (ext & C_B)
		strcat (Code, B);
	else if (ext & C_W)
		strcat (Code, W);
	if (ext & C_L)
		strcat (Code, L);
}

VOID FindMemoryAera (ULONG address, char *MemName)
{
  struct Node *node;
  ULONG *end;

	Forbid ();
	node = SysBase->MemList.lh_Head;
	while (node->ln_Succ)
	{
		end = (ULONG *)node;
		end += 6;

		mem_start = (ULONG)node;
		mem_end = (ULONG)*end - 1;

		if (mem_start == 0x1000)	// chip?
			mem_start = 0;
		
		if ((address >= mem_start) AND (address <= mem_end))
		{
			if (*node->ln_Name)
				strcpy (MemName, node->ln_Name);
			else
				strcpy (MemName, GLS (&L_NA));

 			break;
		}
		node = node->ln_Succ;
	}
	Permit ();
}

ULONG CheckMemAddress (ULONG address)
{
	if (address > mem_end)
		return (mem_start);
	else if (address < mem_start)
		return (mem_end);
	else
		return (address);
}

UWORD mm_minus[] =	// movem.l -(sp)
{
	0x8000,
	0x4000,
	0x2000,
	0x1000,
	0x0800,
	0x0400,
	0x0200,
	0x0100,
	0x0080,
	0x0040,
	0x0020,
	0x0010,
	0x0008,
	0x0004,
	0x0002,
	0x0001
};	

UWORD mm_plus[] =	// movem.l (sp)+
{
	0x0001,
	0x0002,
	0x0004,
	0x0008,
	0x0010,
	0x0020,
	0x0040,
	0x0080,
	0x0100,
	0x0200,
	0x0400,
	0x0800,
	0x1000,
	0x2000,
	0x4000,
	0x8000
};	

char D_reg[][3] = { "D0", "D1", "D2", "D3", "D4", "D5", "D6", "D7" };
char A_reg[][3] = { "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7" };

VOID GetMovemRegs (char *String, UWORD p, BOOL mode)
{
	UBYTE i;
	BOOL flag;
	BOOL start, stop;
	char Hold[10];
	BOOL tmp;

	String[0] = flag = start = stop = 0;
	for (i = 0; i < 16; i++)
	{
		tmp = 0;
		if (mode)	// sp+
		{
			if (p & mm_plus[i])
				tmp = TRUE;
		}
		else			// -sp
		{
			if (p & mm_minus[i])
				tmp = TRUE;
		}

		if (tmp)	// Valid?
		{
			if (!flag)
			{
				start = i;
				flag = TRUE;
			}
		}
		else if (i > 0)	// JA
		{
			stop = i - 1;
			if (flag)
			{
				if (start == stop)	// Only one?
				{
					if (start <= 7)	// d0
						sprintf (Hold, "%s/", D_reg[start]);
					else
						sprintf (Hold, "%s/", A_reg[start - 8]);
					strcat (String, Hold);
				}
				else
				{
					if (start <= 7)	// d0
						sprintf (Hold, "%s-", D_reg[start]);
					else
						sprintf (Hold, "%s-", A_reg[start - 8]);
					strcat (String, Hold);

					if (stop <= 7)	// d0
						sprintf (Hold, "%s/", D_reg[stop]);
					else
						sprintf (Hold, "%s/", A_reg[stop - 8]);
					strcat (String, Hold);
				}
				flag = FALSE;
			}
			start = 0;
		}
	}
	stop = i - 1;
	if (flag)
	{
		if (start == stop)	// Only one?
		{
			if (start <= 7)	// d0
				sprintf (Hold, "%s/", D_reg[start]);
			else
				sprintf (Hold, "%s/", A_reg[start - 8]);
			strcat (String, Hold);
		}
		else
		{
			if (start <= 7)	// d0
				sprintf (Hold, "%s-", D_reg[start]);
			else
				sprintf (Hold, "%s-", A_reg[start - 8]);
			strcat (String, Hold);

			if (stop <= 7)	// d0
				sprintf (Hold, "%s/", D_reg[stop]);
			else
				sprintf (Hold, "%s/", A_reg[stop - 8]);
			strcat (String, Hold);
		}
	}
	if (String[strlen (String)-1] == '/')
		String[strlen (String)-1] = 0;
}

char C_Branches[16][4] =
{
	"BRA",
	"BSR",
	"BHI",
	"BLS",
	"BCC",
	"BCS",
	"BNE",
	"BEQ",
	"BVC",
	"BVS",
	"BPL",
	"BMI",
	"BGE",
	"BLT",
	"BGT",
	"BLE"
};

UBYTE CheckBranches (ULONG address, UWORD p, WORD p1, LONG p2, char *Code, char *Code1, char *CPU)
{
	UWORD tmp;

	tmp = p;
	tmp -= 0x60ff;
	if ((tmp>>12 == 0) AND ((UBYTE)tmp == 0))	// LONG
	{
		strcpy (Code, C_Branches[tmp>>8]);
		strcat (Code, L);
		sprintf (Code1, Formats[12], address + p2 + 2);
		strcpy (CPU, C_020);

		return (6);
	}

	tmp = p;
	tmp -= 0x6000;
	if ((tmp>>12 == 0) AND ((UBYTE)tmp == 0))
	{
		strcpy (Code, C_Branches[tmp>>8]);
		strcat (Code, W);

		sprintf (Code1, Formats[12], address + p1 + 2);
		return (4);
	}

	tmp = p;
	tmp -= 0x6000;
	if (tmp>>12 == 0)
	{
		strcpy (Code, C_Branches[tmp>>8]);
		strcat (Code, B);

		sprintf (Code1, Formats[12], address + (BYTE)p + 2);
		return (2);
	}
	return (0);
}

UBYTE FindCode (ULONG address, char *Code, char *Code1, char *CPU)
{
	UWORD *p;
	UWORD *p1;
	ULONG *p2;
	UWORD *p3;
	ULONG *p4;
	UWORD d_reg, a_reg, reg;
	UWORD value;
	UBYTE b_ret;

	p = (UWORD *)address;

	p1 = p;
	p1++;

	p2 = (ULONG *)p1;
	p3 = (UWORD *)p2;
	p3 += 2;
	p4 = (ULONG *)p;
	p4++;

	b_ret = CheckBranches (address, *p, (WORD)*p1, (LONG)*p2, Code, Code1, CPU);
	if (b_ret)
		return (b_ret);
	
	if (*p>>8 == 0x0c)
	{
		if ((UBYTE)*p >= 0x70 AND (UBYTE)*p <= 0x77)
		{
			if ((a_reg = GetReg4Low (*p)) != -1)						// cmpi.w #$xxxx,($xx,ax,dx.w)
			{
				d_reg = (UWORD)*p2>>12;
				if (d_reg >= 0 AND d_reg <= 7)
				{
					UBYTE val;

					MakeCode (Code, C_CMP, C_I1|C_W); 
					if (val = CheckNeg_b ((UBYTE)*p2))	// Neg?
						sprintf (Code1, "#$%04lX,(-$%02lX,%s,%s.W)", *p1, val, A_reg[a_reg], D_reg[d_reg]);
					else
						sprintf (Code1, "#$%04lX,($%02lX,%s,%s.W)", *p1, (UBYTE)*p2, A_reg[a_reg], D_reg[d_reg]);
					return (6);
				}
			}
		}
	}

	if (*p>>8 == 0x06)
	{
		if ((UBYTE)*p >= 0x80 AND (UBYTE)*p <= 0x87)
		{
			if ((d_reg = GetReg4Low (*p)) != -1)						// addi.l	#$xxxxxxxx,dx
			{
				MakeCode (Code, C_ADD, C_I1|C_L); 
				sprintf (Code1, Formats[6], *p2, D_reg[d_reg]);
				return (6);
			}
		}
	}

	// ***************************** LEA *************************************
	if (*p>>12 == 0x4)
	{
		MakeCode (Code, C_LEA, 0); 

		if ((UBYTE)*p == 0xf8)								// lea $xxxx.w,ax
		{
			if ((a_reg = GetReg2Odd (*p)) != -1)
			{
				if (value = CheckNeg_w (*p1))	// Neg?
					sprintf (Code1, "-$%04lX,%s", value, A_reg[a_reg]);
				else
					sprintf (Code1, "$%04lX,%s", *p1, A_reg[a_reg]);
				return (4);
			}
		}
		else if ((UBYTE)*p == 0xf9)						// lea $xxxxxxx,ax ?
		{
			if ((a_reg = GetReg2Odd (*p)) != -1)
			{
				sprintf (Code1, Formats[11], *p2, A_reg[a_reg]);
				return (6);
			}
		}
		else if ((UBYTE)*p == 0xfa)				// lea	(Buf,pc),a0 ?
		{
			if ((a_reg = GetReg2Odd (*p)) != -1)
			{
				sprintf (Code1, Formats[47], address + *p1 + 2, A_reg[a_reg]);
				return (4);
			}
		}
		else if ((UBYTE)*p >= 0xe8 AND (UBYTE)*p <= 0xef)	// lea ($0000,ax),ax
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Odd (*p)) != -1)
				{
					sprintf (Code1, Formats[33], *p1, A_reg[a_reg], A_reg[d_reg]);
					return (4);
				}
			}
		}
	}

	// ************************************************************************


	if (*p>>8 == 0x4e)
	{
		MakeCode (Code, C_JMP, 0); 
		if ((UBYTE)*p == 0xf9)	// jmp $xxxxxxxx
		{
			sprintf (Code1, Formats[12], *p2);
			return (6);
		}
		else if ((UBYTE)*p >= 0xe0 AND (UBYTE)*p <= 0xeF) 	// jmp (-$xxxx,ax)
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if (value = CheckNeg_w (*p1))	// Neg?
					sprintf (Code1, Formats[13], value, A_reg[a_reg]);
				else
					sprintf (Code1, Formats[14], (UWORD)*p1, A_reg[a_reg]);
				return (4);
			}
		}
		else if ((UBYTE)*p >= 0xd0 AND (UBYTE)*p <= 0xd7)	// jmp (ax)
		{
			if (!(a_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[1], A_reg[a_reg]);
				return (2);
			}
		}
	}

	// ***************************** SUBA.W ***********************************
	if (*p>>12 == 0x9)
	{
		MakeCode (Code, C_SUB, C_A1|C_W); 

		if ((UBYTE)*p == 0xfc)	// suba.l #$0000,ax
		{
			if ((a_reg = GetReg2Even (*p)) != -1)
			{
				sprintf (Code1, Formats[53], *p1, A_reg[a_reg]);
				return (4);
			}
		}
	}
	// ***************************** SUBA.L ***********************************
	if (*p>>12 == 0x9)
	{
		MakeCode (Code, C_SUB, C_A1|C_L); 

		if ((UBYTE)*p == 0xfc)	// suba.l #$00000000,ax
		{
			if ((a_reg = GetReg2Odd (*p)) != -1)
			{
				sprintf (Code1, Formats[6], *p2, A_reg[a_reg]);
				return (6);
			}
		}
		else if ((UBYTE)*p >= 0xc8 AND (UBYTE)*p <= 0xcf)	// suba.l ax,ax
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Odd (*p)) != -1)
				{
					sprintf (Code1, Formats[44], A_reg[a_reg], A_reg[d_reg]);
					return (2);
				}
			}
		}
	}

	if (*p>>12 == 0xb AND (UBYTE)*p == 0xf9)	// CMPA.L $00000000,ax
	{
		if ((a_reg = GetReg2Odd (*p)) != -1)
		{
			MakeCode (Code, C_CMP, C_A1|C_L); 
			sprintf (Code1, Formats[11], *p2, A_reg[a_reg]);
			return (6);
		}
	}

	if (*p>>8 == 0x48)
	{
		if ((UBYTE)*p >= 0xa8 AND (UBYTE)*p <= 0xaf) 	// movem.w dx/ax,($0000,ax)
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				char Hold[20];

				MakeCode (Code, C_MOVEM, C_W); 

				Code1[0] = 0;
				GetMovemRegs (Code1, *p1, 1);

				sprintf (Hold, Formats[17], (UWORD)*p2, A_reg[a_reg]);
				strcat (Code1, Hold);
				return (6);
			}
		}
	}

	// ***************************** PEA **************************************
	if (*p>>8 == 0x48)
	{
		MakeCode (Code, C_PEA, 0); 
	
		if ((UBYTE)*p == 0x7a)	// pea ($00000000,pc)
		{
			sprintf (Code1, Formats[21], address + (WORD)*p1 + 2);
			return (4);
		}
		else if ((UBYTE)*p == 0x79)	// pea $00000000
		{
			sprintf (Code1, Formats[12], *p2);
			return (6);
		}
		else if ((UBYTE)*p >= 0x50 AND (UBYTE)*p <= 0x57) 	// pea (ax)
		{
			if ((a_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[1],  A_reg[a_reg]);
				return (2);
			}
		}
	}

	if (*p>>8 == 0x08)	// BSET
	{
		MakeCode (Code, C_BSET, 0); 
		if ((UBYTE)*p >= 0xc0 AND (UBYTE)*p <= 0xc7) 	// BSET #$0000,dx
		{
			if ((d_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[22], *p1, D_reg[d_reg]);
				return (4);
			}
		}
		else if ((UBYTE)*p >= 0xd0 AND (UBYTE)*p <= 0xd7) 	// BSET #$0000,(ax)
		{
			if ((a_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[27], *p1, A_reg[a_reg]);
				return (4);
			}
		}
		else if ((UBYTE)*p >= 0xd8 AND (UBYTE)*p <= 0xdf) 	// BSET #$0000,(ax)+
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				sprintf (Code1, Formats[28], *p1, A_reg[a_reg]);
				return (4);
			}
		}
		else if ((UBYTE)*p >= 0xe0 AND (UBYTE)*p <= 0xe7) 	// BSET #$0000,-(ax)
		{
			if ((a_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[29], *p1, A_reg[a_reg]);
				return (4);
			}
		}
	}

	if (*p == 0x48e7)	// movem.l dx/ax,-(sp)
	{
		MakeCode (Code, C_MOVEM, C_L); 
		GetMovemRegs (Code1, *p1, 0);
		strcat (Code1, ",-(A7)");

		return (4);
	}
	else if (*p == 0x4cdf)	// movem.l (sp)+,dx/ax
	{
		char Regs[20];

		MakeCode (Code, C_MOVEM, C_L); 
		strcpy (Code1, "(A7)+,");
		GetMovemRegs (Regs, *p1, 1);
		strcat (Code1, Regs);

		return (4);
	}
	else if (*p == 0x4cf9)	// movem.l $xxxxxxxx,dx/ax
	{
		char Regs[20];

		MakeCode (Code, C_MOVEM, C_L);
		sprintf (Code1, Formats[55], *p4);
		GetMovemRegs (Regs, *p1, 1);
		strcat (Code1, Regs);

		return (8);
	}

	if (*p>>8 == 0x4c)	// movem.l ($-xxxx,ax),dx/ax
	{
		if ((UBYTE)*p >= 0xe8 AND (UBYTE)*p <= 0xef)
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				char Regs[20];

				MakeCode (Code, C_MOVEM, C_L); 
				if (value = CheckNeg_w ((UWORD)*p2))	// Neg?
					sprintf (Code1, "(-$%04lX,%s),", value, A_reg[a_reg]);
				else
					sprintf (Code1, "($%04lX,%s),", (UWORD)*p2, A_reg[a_reg]);

				GetMovemRegs (Regs, *p1, 1);
				strcat (Code1, Regs);

				return (6);
			}
		}
	}


	if (*p == 0x50f9)	// st $00000000
	{
		MakeCode (Code, C_ST, 0); 
		sprintf (Code1, Formats[12], *p2);
		return (6);
	}

	if (*p == 0x4eb9)	// jsr $00000000
	{
		MakeCode (Code, C_JSR, 0); 
		sprintf (Code1, Formats[12], *p2);
		return (6);
	}
	if (*p>>8 == 0x4e)	// jsr (-$xxxx,ax)
	{
		if ((UBYTE)*p >= 0xA8 AND (UBYTE)*p <= 0xAF)
		{
			a_reg = *p;
			a_reg -= 0x4ea8;
			if (a_reg < 8)
			{
				if (value = CheckNeg_w (*p1))	// Neg?
					sprintf (Code1, Formats[13], value, A_reg[a_reg]);
				else
					sprintf (Code1, Formats[14], (UWORD)*p1, A_reg[a_reg]);
				return (4);
			}
		}
		else if ((UBYTE)*p >= 0x90 AND (UBYTE)*p <= 0x97)	// jsr (ax)
		{
			if (!(a_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[1], A_reg[a_reg]);
				return (2);
			}
		}
	}

	if (*p>>8 == 0x4e)	// link.w ax,#$xxxx
	{
		if ((UBYTE)*p >= 0x50 AND (UBYTE)*p <= 0x57)
		{
			a_reg = *p;
			a_reg -= 0x4e50;
			if (a_reg < 8)
			{
				MakeCode (Code, C_LINK, C_W); 
				sprintf (Code1, Formats[46], A_reg[a_reg], *p1);
				return (4);
			}
		}
	}

	if (*p>>8 == 0x08)
	{
		MakeCode (Code, C_BTST, 0); 

		if ((UBYTE)*p >= 0x00 AND (UBYTE)*p <= 0x07) //	btst #$xxxx,dx
		{
			d_reg = *p;
			d_reg -= 0x0800;
			if (d_reg < 8)
			{
				sprintf (Code1, Formats[22], *p1, D_reg[d_reg]);
				return (4);
			}
		}
		else if ((UBYTE)*p >= 0x20 AND (UBYTE)*p <= 0x27) 	// btst #$xxxx,-(ax)
		{
			a_reg = *p;
			a_reg -= 0x0820;
			if (a_reg < 8)
			{
				sprintf (Code1, Formats[26], (UBYTE)*p1, A_reg[a_reg]);
				return (4);
			}
		}
		else if ((UBYTE)*p >= 0x28 AND (UBYTE)*p <= 0x2f) 	// btst #$xx,($0000,ax)
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				sprintf (Code1, Formats[15], (UBYTE)*p1, (UWORD)*p2, A_reg[a_reg]);
				return (6);
			}
		}
	}
	if (*p>>8 == 0x02)	// ANDI.B dx
	{
		if ((UBYTE)*p >= 0x00 AND (UBYTE)*p <= 0x07)
		{
			if ((d_reg = GetReg4Low (*p)) != -1)
			{
				MakeCode (Code, C_AND, C_I1|C_B); 
				sprintf (Code1, Formats[22],  *p1, D_reg[d_reg]);
				return (4);
			}
		}
	}
	if (*p>>8 == 0x02)	// AND.W dx
	{
		if ((UBYTE)*p >= 0x40 AND (UBYTE)*p <= 0x47)
		{
			if ((d_reg = GetReg4Low (*p)) != -1)
			{
				MakeCode (Code, C_AND, C_I1|C_W); 
				sprintf (Code1, Formats[22],  *p1, D_reg[d_reg]);
				return (4);
			}
		}
	}
	if (*p>>12 == 0xB AND (UBYTE)*p == 0xfc)	// CMPA.W #$0000,ax
	{
		if ((a_reg = GetReg2Even (*p)) != -1)
		{
			MakeCode (Code, C_CMP, C_A1|C_W); 
			sprintf (Code1, Formats[22],  *p1, A_reg[a_reg]);
			return (4);
		}
	}
	if (*p>>12 == 0xB AND (UBYTE)*p == 0xfc)	// CMPA.L #$00000000,ax
	{
		if ((a_reg = GetReg2Odd (*p)) != -1)
		{
			MakeCode (Code, C_CMP, C_A1|C_L); 
			sprintf (Code1, Formats[6],  *p2, A_reg[a_reg]);
			return (6);
		}
	}

	if (*p>>12 == 0x9)
	{
		if ((UBYTE)*p >= 0x68 AND (UBYTE)*p <= 0x6f)	// sub.w ($0000,ax),dx
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Even (*p)) != -1)
				{
					MakeCode (Code, C_SUB, C_W); 
					sprintf (Code1, Formats[33], *p1, A_reg[a_reg], D_reg[d_reg]);
					return (4);
				}
			}
		}
	}
	if (*p>>12 == 0x8)
	{
		if ((UBYTE)*p >= 0x68 AND (UBYTE)*p <= 0x6f)	// or.w ($0000,ax),dx
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Even (*p)) != -1)
				{
					MakeCode (Code, C_OR, C_W); 
					sprintf (Code1, Formats[33], *p1, A_reg[a_reg], D_reg[d_reg]);
					return (4);
				}
			}
		}
	}
	if (*p>>12 == 0xb)
	{
		if ((UBYTE)*p >= 0x68 AND (UBYTE)*p <= 0x6f)	// cmp.w ($0000,ax),dx
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Even (*p)) != -1)
				{
					MakeCode (Code, C_CMP, C_W); 
					sprintf (Code1, Formats[33], *p1, A_reg[a_reg], D_reg[d_reg]);
					return (4);
				}
			}
		}
	}
	if (*p>>12 == 0x8)
	{
		if ((UBYTE)*p >= 0xe8 AND (UBYTE)*p <= 0xef)	// mulu.w ($0000,ax),dx
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Even (*p)) != -1)
				{
					MakeCode (Code, C_MULU, C_W); 
					sprintf (Code1, Formats[33], *p1, A_reg[a_reg], D_reg[d_reg]);
					return (4);
				}
			}
		}
	}
	if (*p>>12 == 0x9)
	{
		if ((UBYTE)*p >= 0xe8 AND (UBYTE)*p <= 0xef)	// suba.w ($0000,ax),ax
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Even (*p)) != -1)
				{
					MakeCode (Code, C_SUB, C_A1|C_W); 
					sprintf (Code1, Formats[33], *p1, A_reg[a_reg], A_reg[d_reg]);
					return (4);
				}
			}
		}
	}
	if (*p>>12 == 0xb)
	{
		if ((UBYTE)*p >= 0xe8 AND (UBYTE)*p <= 0xef)	// cmp.w ($0000,ax),ax
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Even (*p)) != -1)
				{
					MakeCode (Code, C_CMP, C_W); 
					sprintf (Code1, Formats[33], *p1, A_reg[a_reg], A_reg[d_reg]);
					return (4);
				}
			}
		}
	}
	if (*p>>12 == 0xc)
	{
		if ((UBYTE)*p >= 0xe8 AND (UBYTE)*p <= 0xef)	// mulu.w ($0000,ax),dx
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Even (*p)) != -1)
				{
					MakeCode (Code, C_MULU, C_W); 
					sprintf (Code1, Formats[33], *p1, A_reg[a_reg], D_reg[d_reg]);
					return (4);
				}
			}
		}
		else if ((UBYTE)*p >= 0xc0 AND (UBYTE)*p <= 0xc7)	// mulu.w dx,dx
		{
			if ((d_reg = GetReg4Low (*p)) != -1)
			{
				if ((a_reg = GetReg2Even (*p)) != -1)
				{
					sprintf (Code1, Formats[44], D_reg[d_reg], D_reg[a_reg]);
					return (2);
				}
			}
		}
	}
	if (*p>>12 == 0xd)	// ADDA.W
	{
		MakeCode (Code, C_ADD, C_A1|C_W); 

		if ((UBYTE)*p >= 0xe8 AND (UBYTE)*p <= 0xef)	// adda.w ($0000,ax),ax
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Even (*p)) != -1)
				{
					sprintf (Code1, Formats[33], *p1, A_reg[a_reg], A_reg[d_reg]);
					return (4);
				}
			}
		}
		else if ((UBYTE)*p >= 0xc0 AND (UBYTE)*p <= 0xc7)	// adda.w dx,ax
		{
			if ((d_reg = GetReg4Low (*p)) != -1)
			{
				if ((a_reg = GetReg2Even (*p)) != -1)
				{
					sprintf (Code1, Formats[44], D_reg[d_reg], A_reg[a_reg]);
					return (2);
				}
			}
		}
		else if ((UBYTE)*p == 0xfc)				// adda.w #$xxxx,ax
		{
			if ((a_reg = GetReg2Even (*p)) != -1)
			{
				sprintf (Code1, Formats[22], *p1, A_reg[a_reg]);
				return (4);
			}
		}
	}

	if (*p>>12 == 0x8)
	{
		if ((UBYTE)*p >= 0x28 AND (UBYTE)*p <= 0x2f)	// or.b ($0000,ax),dx
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Even (*p)) != -1)
				{
					MakeCode (Code, C_OR, C_B); 
					sprintf (Code1, Formats[33], *p1, A_reg[a_reg], D_reg[d_reg]);
					return (4);
				}
			}
		}
	}
	if (*p>>12 == 0x9)
	{
		if ((UBYTE)*p >= 0x28 AND (UBYTE)*p <= 0x2f)	// sub.b ($0000,ax),dx
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Even (*p)) != -1)
				{
					MakeCode (Code, C_SUB, C_B); 
					sprintf (Code1, Formats[33], *p1, A_reg[a_reg], D_reg[d_reg]);
					return (4);
				}
			}
		}
	}
	if (*p>>12 == 0x9)
	{
		if ((UBYTE)*p >= 0xa8 AND (UBYTE)*p <= 0xaf)	// sub.l ($0000,ax),dx
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Even (*p)) != -1)
				{
					MakeCode (Code, C_SUB, C_L); 
					sprintf (Code1, Formats[33], *p1, A_reg[a_reg], D_reg[d_reg]);
					return (4);
				}
			}
		}
	}

	if (*p>>12 == 0xb)
	{
		if ((UBYTE)*p >= 0x28 AND (UBYTE)*p <= 0x2f)	// cmp.b ($0000,ax),dx
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Even (*p)) != -1)
				{
					MakeCode (Code, C_CMP, C_B); 
					sprintf (Code1, Formats[33], *p1, A_reg[a_reg], D_reg[d_reg]);
					return (4);
				}
			}
		}
	}
	if (*p>>12 == 0xc)
	{
		if ((UBYTE)*p >= 0x28 AND (UBYTE)*p <= 0x2f)	// and.b ($0000,ax),dx
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Even (*p)) != -1)
				{
					MakeCode (Code, C_AND, C_B); 
					sprintf (Code1, Formats[33], *p1, A_reg[a_reg], D_reg[d_reg]);
					return (4);
				}
			}
		}
	}
	if (*p>>12 == 0xd)
	{
		if ((UBYTE)*p >= 0x28 AND (UBYTE)*p <= 0x2f)	// add.b ($0000,ax),dx
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Even (*p)) != -1)
				{
					MakeCode (Code, C_ADD, C_B); 
					sprintf (Code1, Formats[33], *p1, A_reg[a_reg], D_reg[d_reg]);
					return (4);
				}
			}
		}
	}

	if (*p>>12 == 0xb)	// cmp.l	dx,dx
	{
		if ((UBYTE)*p >= 0x80 AND (UBYTE)*p <= 0x87)
		{
			if ((d_reg = GetReg4Low (*p)) != -1)
			{
				if ((a_reg = GetReg2Even (*p)) != -1)
				{
					MakeCode (Code, C_CMP, C_L); 
					sprintf (Code1, Formats[44], D_reg[d_reg], D_reg[a_reg]);
					return (2);
				}
			}
		}
	}

	if (*p>>8 == 0x0c)	// cmpi.x
	{
		MakeCode (Code, C_CMP, C_I1|C_B); 
		if ((UBYTE)*p >= 0x00 AND (UBYTE)*p <= 0x07)	// #$00,d0
		{
			if ((d_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[23], (UBYTE)*p1, D_reg[d_reg]);
				return (4);
			}
		}
		else if ((UBYTE)*p >= 0x10 AND (UBYTE)*p <= 0x17)	// #$00,(ax)
		{
			if ((a_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[24], (UBYTE)*p1, A_reg[a_reg]);
				return (4);
			}
		}
		else if ((UBYTE)*p >= 0x18 AND (UBYTE)*p <= 0x1f)	// #$00,(ax)+
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				sprintf (Code1, Formats[25], (UBYTE)*p1, A_reg[a_reg]);
				return (4);
			}
		}
		else if ((UBYTE)*p >= 0x20 AND (UBYTE)*p <= 0x27)	// #$00,-(ax)
		{
			if ((a_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[26], (UBYTE)*p1, A_reg[a_reg]);
				return (4);
			}
		}

		MakeCode (Code, C_CMP, C_I1|C_W); 
		if ((UBYTE)*p >= 0x40 AND (UBYTE)*p <= 0x47)	// #$0000,dx
		{
			if ((d_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[22], *p1, D_reg[d_reg]);
				return (4);
			}
		}
		else if ((UBYTE)*p >= 0x50 AND (UBYTE)*p <= 0x57)	// (ax)
		{
			if ((a_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[27], *p1, A_reg[a_reg]);
				return (4);
			}
		}
		else if ((UBYTE)*p >= 0x58 AND (UBYTE)*p <= 0x5f)	// (ax)+
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				sprintf (Code1, Formats[28], *p1, A_reg[a_reg]);
				return (4);
			}
		}
		else if ((UBYTE)*p >= 0x60 AND (UBYTE)*p <= 0x67)	// -(ax)
		{
			if ((a_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[29], *p1, A_reg[a_reg]);
				return (4);
			}
		}

		MakeCode (Code, C_CMP, C_I1|C_L); 
		if ((UBYTE)*p >= 0x80 AND (UBYTE)*p <= 0x87)	// #$00000000,dx
		{
			if ((d_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[6], *p2, D_reg[d_reg]);
				return (6);
			}
		}
		else if ((UBYTE)*p >= 0x90 AND (UBYTE)*p <= 0x97)	// #$00000000,(ax)
		{
			if ((a_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[30], *p2, A_reg[a_reg]);
				return (6);
			}
		}
		else if ((UBYTE)*p >= 0x98 AND (UBYTE)*p <= 0x9f)	// #$00000000,(ax)+
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				sprintf (Code1, Formats[31], *p2, A_reg[a_reg]);
				return (6);
			}
		}
		else if ((UBYTE)*p >= 0xa0 AND (UBYTE)*p <= 0xa7)	// #$00000000,-(ax)
		{
			if ((a_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[32], *p2, A_reg[a_reg]);
				return (6);
			}
		}
	}

	if (*p>>12 == 0x8)
	{
		if ((UBYTE)*p >= 0xe8 AND (UBYTE)*p <= 0xef)	// divs.w ($0000,ax),ax
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Odd (*p)) != -1)
				{
					MakeCode (Code, C_DIVS, C_W);
					sprintf (Code1, Formats[33], *p1, A_reg[a_reg], D_reg[d_reg]);
					return (4);
				}
			}
		}
	}
	if (*p>>12 == 0x9)
	{
		if ((UBYTE)*p >= 0xe8 AND (UBYTE)*p <= 0xef)	// sub.l ($0000,ax),ax
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Odd (*p)) != -1)
				{
					MakeCode (Code, C_SUB, C_A1|C_L);
					sprintf (Code1, Formats[33], *p1, A_reg[a_reg], A_reg[d_reg]);
					return (4);
				}
			}
		}
	}
	if (*p>>12 == 0xb)
	{
		if ((UBYTE)*p >= 0xe8 AND (UBYTE)*p <= 0xef)	// cmpa.l ($0000,ax),ax
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Odd (*p)) != -1)
				{
					MakeCode (Code, C_CMP, C_A1|C_L);
					sprintf (Code1, Formats[33], *p1, A_reg[a_reg], A_reg[d_reg]);
					return (4);
				}
			}
		}
	}
	if (*p>>12 == 0xc)
	{
		if ((UBYTE)*p >= 0xe8 AND (UBYTE)*p <= 0xef)	// muls.w ($0000,ax),ax
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Odd (*p)) != -1)
				{
					MakeCode (Code, C_MULS, C_W);
					sprintf (Code1, Formats[33], *p1, A_reg[a_reg], D_reg[d_reg]);
					return (4);
				}
			}
		}
	}
	if (*p>>12 == 0xd)
	{
		if ((UBYTE)*p >= 0xe8 AND (UBYTE)*p <= 0xef)	// adda.l ($0000,ax),ax
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Odd (*p)) != -1)
				{
					MakeCode (Code, C_ADD, C_A1|C_L);
					sprintf (Code1, Formats[33], *p1, A_reg[a_reg], A_reg[d_reg]);
					return (4);
				}
			}
		}
	}


// *********************************** 2 BYTES ***************************

	if (*p>>12 == 0xe)
	{
		if ((UBYTE)*p >= 0x48 AND (UBYTE)*p <= 0x4F)	// lsr.w	#x,dx
		{
			UWORD val;

			if ((val = GetReg2Even (*p)) != -1)
			{
				if (val == 0)
					val = 8;
				if ((d_reg = GetReg4High (*p)) != -1)
				{
					MakeCode (Code, C_LSR, C_W);
					sprintf (Code1, Formats[38], val, D_reg[d_reg]);
					return (2);
				}
			}
		}
		if ((UBYTE)*p >= 0x88 AND (UBYTE)*p <= 0x8F)	// lsr.l	#x,dx
		{
			UWORD val;

			if ((val = GetReg2Even (*p)) != -1)
			{
				if (val == 0)
					val = 8;
				if ((d_reg = GetReg4High (*p)) != -1)
				{
					MakeCode (Code, C_LSR, C_L);
					sprintf (Code1, Formats[38], val, D_reg[d_reg]);
					return (2);
				}
			}
		}
		if ((UBYTE)*p >= 0x48 AND (UBYTE)*p <= 0x4f)	// lsl.w	#x,dx
		{
			UWORD val;

			if ((val = GetReg2Odd (*p)) != -1)
			{
				if (val == 0)
					val = 8;
				if ((d_reg = GetReg4High (*p)) != -1)
				{
					MakeCode (Code, C_LSL, C_W);
					sprintf (Code1, Formats[38], val, D_reg[d_reg]);
					return (2);
				}
			}
		}
		if ((UBYTE)*p >= 0x88 AND (UBYTE)*p <= 0x8f)	// lsl.l	#x,dx
		{
			UWORD val;

			if ((val = GetReg2Odd (*p)) != -1)
			{
				if (val == 0)
					val = 8;
				if ((d_reg = GetReg4High (*p)) != -1)
				{
					MakeCode (Code, C_LSL, C_L);
					sprintf (Code1, Formats[38], val, D_reg[d_reg]);
					return (2);
				}
			}
		}
		if ((UBYTE)*p >= 0x40 AND (UBYTE)*p <= 0x47)	// asr.w	#x,dx
		{
			UWORD val;

			if ((val = GetReg2Even (*p)) != -1)
			{
				if (val == 0)
					val = 8;
				if ((d_reg = GetReg4Low (*p)) != -1)
				{
					MakeCode (Code, C_ASR, C_W);
					sprintf (Code1, Formats[38], val, D_reg[d_reg]);
					return (2);
				}
			}
		}
		if ((UBYTE)*p >= 0x80 AND (UBYTE)*p <= 0x87)	// asr.l	#x,dx
		{
			UWORD val;

			if ((val = GetReg2Even (*p)) != -1)
			{
				if (val == 0)
					val = 8;
				if ((d_reg = GetReg4Low (*p)) != -1)
				{
					MakeCode (Code, C_ASR, C_L);
					sprintf (Code1, Formats[38], val, D_reg[d_reg]);
					return (2);
				}
			}
		}
	}

	if (*p>>12 == 0xb)
	{
		if ((UBYTE)*p >= 0xc8 AND (UBYTE)*p <= 0xcf)	// CMPA.L ax,ax
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				MakeCode (Code, C_CMP, C_A1|C_L);
				if ((d_reg = GetReg2Odd (*p)) != -1)
					strcat (Code, L);
				else if ((d_reg = GetReg2Even (*p)) != -1)
					strcat (Code, W);

				sprintf (Code1, Formats[44], A_reg[a_reg], A_reg[d_reg]);
				return (2);
			}
		}
	}

	if (*p>>8 == 0x44)
	{
		MakeCode (Code, C_NEG, C_B);
		if ((UBYTE)*p >= 0x10 AND (UBYTE)*p <= 0x17)	// neg.b (ax)
		{
			if ((a_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[1], A_reg[a_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0x18 AND (UBYTE)*p <= 0x1f)	// neg.b (ax)+
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				sprintf (Code1, Formats[2], A_reg[a_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0x20 AND (UBYTE)*p <= 0x27)	// neg.b -(ax)
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				sprintf (Code1, Formats[3], A_reg[a_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0x00 AND (UBYTE)*p <= 0x07)	// neg.b dx
		{
			if ((d_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[0], D_reg[d_reg]);
				return (2);
			}
		}

		MakeCode (Code, C_NEG, C_W);
		if ((UBYTE)*p >= 0x50 AND (UBYTE)*p <= 0x57)	// neg.w (ax)
		{
			if ((a_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[1], A_reg[a_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0x58 AND (UBYTE)*p <= 0x5f)	// neg.w (ax)+
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				sprintf (Code1, Formats[2], A_reg[a_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0x60 AND (UBYTE)*p <= 0x67)	// neg.w -(ax)
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				sprintf (Code1, Formats[3], A_reg[a_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0x40 AND (UBYTE)*p <= 0x47)	// neg.w dx
		{
			if ((d_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[0], D_reg[d_reg]);
				return (2);
			}
		}

		MakeCode (Code, C_NEG, C_L);
		if ((UBYTE)*p >= 0x90 AND (UBYTE)*p <= 0x97)	// neg.l (ax)
		{
			if ((a_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[1], A_reg[a_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0x98 AND (UBYTE)*p <= 0x9f)	// neg.l (ax)+
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				sprintf (Code1, Formats[2], A_reg[a_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0xa0 AND (UBYTE)*p <= 0xa7)	// neg.l -(ax)
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				sprintf (Code1, Formats[3], A_reg[a_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0x80 AND (UBYTE)*p <= 0x87)	// neg.l dx
		{
			if ((d_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[0], D_reg[d_reg]);
				return (2);
			}
		}
	}

	if (*p>>8 == 0x48)
	{
		if ((UBYTE)*p >= 0xc0 AND (UBYTE)*p <= 0xc7)	// ext.l dx
		{
			if ((d_reg = GetReg4Low (*p)) != -1)
			{
				MakeCode (Code, C_EXT, C_L);
				sprintf (Code1, Formats[0], D_reg[d_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0x80 AND (UBYTE)*p <= 0x87)	// ext.w dx
		{
			if ((d_reg = GetReg4Low (*p)) != -1)
			{
				MakeCode (Code, C_EXT, C_W);
				sprintf (Code1, Formats[0], D_reg[d_reg]);
				return (2);
			}
		}
	}

	if (*p>>8 == 0x4e)
	{
		if ((UBYTE)*p >= 0x58 AND (UBYTE)*p <= 0x5f)	// unlk	ax
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				MakeCode (Code, C_UNLK, 0);
				sprintf (Code1, Formats[0], A_reg[a_reg]);
				return (2);
			}
		}
	}

	if (*p == 0x4E70)	// reset
	{
		strcpy (Code, "RESET");
		return (2);
	}
	if (*p == 0x4E71)	// nop
	{
		strcpy (Code, "NOP");
		return (2);
	}
	if (*p == 0x4E72)	// stop #$0000
	{
		strcpy (Code, "STOP");
		sprintf (Code1, Formats[36], *p1);
		return (4);
	}
	if (*p == 0x4E73)	// rts
	{
		strcpy (Code, "RTE");
		return (2);
	}
	if (*p == 0x4E74)	// rtd #$00
	{
		strcpy (Code, "RTD");
		sprintf (Code1, Formats[37], (UBYTE)*p1);
		return (4);
	}
	if (*p == 0x4E75)	// rts
	{
		strcpy (Code, "RTS");
		return (2);
	}
	if (*p == 0x4E76)	// trapv
	{
		strcpy (Code, "TRAPV");
		return (2);
	}
	if (*p == 0x4E77)	// rtr
	{
		strcpy (Code, "RTR");
		return (2);
	}

	if (*p>>8 == 0x42)	// clr.b.w all
	{
		MakeCode (Code, C_CLR, C_B);

		if (*p == 0x4239)	// clr.b $00000000
		{
			sprintf (Code1, Formats[12], *p2);
			return (6);
		}
		if ((UBYTE)*p >= 0x00 AND (UBYTE)*p <= 0x07)	// dx
		{
			if ((d_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[0], D_reg[d_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0x10 AND (UBYTE)*p <= 0x07)	// (ax)
		{
			if ((a_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[1], A_reg[a_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0x18 AND (UBYTE)*p <= 0x1f)	// (ax)+
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				sprintf (Code1, Formats[2], A_reg[a_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0x20 AND (UBYTE)*p <= 0x27)	// -(ax)
		{
			if ((a_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[3], A_reg[a_reg]);
				return (2);
			}
		}

		MakeCode (Code, C_CLR, C_W);
		if (*p == 0x4279)	// clr.w $00000000
		{
			sprintf (Code1, Formats[12], *p2);
			return (6);
		}
		if ((UBYTE)*p >= 0x40 AND (UBYTE)*p <= 0x47)	// dx
		{
			if ((d_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[0], D_reg[d_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0x50 AND (UBYTE)*p <= 0x57)	// (ax)
		{
			if ((a_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[1], A_reg[a_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0x58 AND (UBYTE)*p <= 0x5f)	// (ax)+
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				sprintf (Code1, Formats[2], A_reg[a_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0x60 AND (UBYTE)*p <= 0x67)	// -(ax)
		{
			if ((a_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[3], A_reg[a_reg]);
				return (2);
			}
		}

	// ***************************** CLR.L **********************************
		if (*p>>8 == 0x42)
		{
			MakeCode (Code, C_CLR, C_L);

			if ((UBYTE)*p == 0xb9)	// clr.l $00000000
			{
				sprintf (Code1, Formats[12], *p2);
				return (6);
			}
			else if ((UBYTE)*p >= 0x80 AND (UBYTE)*p <= 0x87)	// dx
			{
				if ((d_reg = GetReg4Low (*p)) != -1)
				{
					sprintf (Code1, Formats[0], D_reg[d_reg]);
					return (2);
				}
			}
			else if ((UBYTE)*p >= 0x90 AND (UBYTE)*p <= 0x97)	// (ax)
			{
				if ((a_reg = GetReg4Low (*p)) != -1)
				{
					sprintf (Code1, Formats[1], A_reg[a_reg]);
					return (2);
				}
			}
			else if ((UBYTE)*p >= 0x98 AND (UBYTE)*p <= 0x9f)	// (ax)+
			{
				if ((a_reg = GetReg4High (*p)) != -1)
				{
					sprintf (Code1, Formats[2], A_reg[a_reg]);
					return (2);
				}
			}
			else if ((UBYTE)*p >= 0xa0 AND (UBYTE)*p <= 0xa7)	// -(ax)
			{
				if ((a_reg = GetReg4Low (*p)) != -1)
				{
					sprintf (Code1, Formats[3], A_reg[a_reg]);
					return (2);
				}
			}
			else if ((UBYTE)*p >= 0xa8 AND (UBYTE)*p <= 0xaf)	// ($xxxx,ax)
			{
				if ((a_reg = GetReg4High (*p)) != -1)
				{
					if (value = CheckNeg_w (*p3))	// Neg?
						sprintf (Code1, "(-$%04lX,%s)", value, A_reg[a_reg]);
					else
						sprintf (Code1, "($%04lX,%s)", *p1, A_reg[a_reg]);

					return (4);
				}
			}
		}
	}

	// **********************************************************************

	if (*p>>8 == 0x4a)	// TST.B all
	{
		MakeCode (Code, C_TST, C_B);

		if (*p == 0x4a39)	// tst.b $00000000
		{
			sprintf (Code1, Formats[12], *p2);
			return (6);
		}
		if ((UBYTE)*p >= 0x00 AND (UBYTE)*p < 0x08)	// dx
		{
			if ((d_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[0], D_reg[d_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0x10 AND (UBYTE)*p < 0x18)	// (ax)
		{
			if ((a_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[1], A_reg[a_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0x20 AND (UBYTE)*p < 0x28)	// -(ax)
		{
			if ((a_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[3], A_reg[a_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0x18 AND (UBYTE)*p <= 0x1f)	// (ax)+
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				sprintf (Code1, Formats[2], A_reg[a_reg]);
				return (2);
			}
		}
	}
	if (*p>>8 == 0x4a)	// TST.W all
	{
		MakeCode (Code, C_TST, C_W);

		if (*p == 0x4a79)	// tst.w $00000000
		{
			sprintf (Code1, Formats[12], *p2);
			return (6);
		}
		if ((UBYTE)*p >= 0x40 AND (UBYTE)*p < 0x48)	// dx
		{
			if ((d_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[0], D_reg[d_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0x48 AND (UBYTE)*p < 0x4f)	// ax
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				sprintf (Code1, Formats[0], A_reg[a_reg]);
				strcpy (CPU, C_020);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0x50 AND (UBYTE)*p < 0x58)	// (ax)
		{
			if ((a_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[1], A_reg[a_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0x60 AND (UBYTE)*p < 0x68)	// -(ax)
		{
			if ((a_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[3], A_reg[a_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0x58 AND (UBYTE)*p <= 0x5f)	// (ax)+
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				sprintf (Code1, Formats[2], A_reg[a_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0x68 AND (UBYTE)*p <= 0x6f)	// ($0000,ax)
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				sprintf (Code1, Formats[14], *p1, A_reg[a_reg]);
				return (4);
			}
		}
	}
	if (*p>>8 == 0x4a)	// TST.L all
	{
		MakeCode (Code, C_TST, C_L);

		if (*p == 0x4ab9)	// tst.l $00000000
		{
			sprintf (Code1, Formats[12], *p2);
			return (6);
		}
		if ((UBYTE)*p >= 0x80 AND (UBYTE)*p <= 0x87)	// dx
		{
			if ((d_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[0], D_reg[d_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0x88 AND (UBYTE)*p < 0x8f)	// ax
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				sprintf (Code1, Formats[0], A_reg[a_reg]);
				strcpy (CPU, C_020);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0x90 AND (UBYTE)*p < 0x98)	// (ax)
		{
			if ((a_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[1], A_reg[a_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0xa0 AND (UBYTE)*p < 0xa8)	// -(ax)
		{
			if ((a_reg = GetReg4Low (*p)) != -1)
			{
				sprintf (Code1, Formats[3], A_reg[a_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0x98 AND (UBYTE)*p <= 0x9f)	// (ax)+
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				sprintf (Code1, Formats[2], A_reg[a_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0xa8 AND (UBYTE)*p < 0xaf)	// ($0000,ax)
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				sprintf (Code1, Formats[14], *p1, A_reg[a_reg]);
				return (4);
			}
		}
	}
	if (*p>>12 == 0x7)	// moveq
	{
		if ((d_reg = GetReg2Even (*p))!= -1)
		{
			MakeCode (Code, C_MOVE, C_Q1);
			sprintf (Code1, Formats[38], (BYTE)*p, D_reg[d_reg]);
			return (2);
		}
	}

	// ***************************** ADD.L **********************************
	if (*p>>12 == 0xd)
	{
		MakeCode (Code, C_ADD, C_L);

		if ((UBYTE)*p >= 0x80 AND (UBYTE)*p <= 0x87) // add.l dx,dx
		{
			if ((d_reg = GetReg2Even (*p)) != -1)
			{
				if ((a_reg = GetReg4Low (*p)) != -1)
				{
					sprintf (Code1, Formats[44], D_reg[a_reg], D_reg[d_reg]);
					return (2);
				}
			}
		}
	}

	// ***************************** ADD.W **********************************
	if (*p>>12 == 0xd)
	{
		MakeCode (Code, C_ADD, C_W);

		if ((UBYTE)*p >= 0x40 AND (UBYTE)*p <= 0x47) // add.w dx,dx
		{
			if ((d_reg = GetReg2Even (*p)) != -1)
			{
				if ((a_reg = GetReg4Low (*p)) != -1)
				{
					sprintf (Code1, Formats[44], D_reg[a_reg], D_reg[d_reg]);
					return (2);
				}
			}
		}
		else if ((UBYTE)*p == 0x7c)				// add.w #$xxxx,dx
		{
			if ((d_reg = GetReg2Even (*p)) != -1)
			{
				sprintf (Code1, Formats[22], *p1, D_reg[d_reg]);
				return (4);
			}
		}
		else if ((UBYTE)*p >= 0x68 AND (UBYTE)*p <= 0x6f)	// add.w ($0000,ax),dx
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Even (*p)) != -1)
				{
					sprintf (Code1, Formats[33], *p1, A_reg[a_reg], D_reg[d_reg]);
					return (4);
				}
			}
		}
	}
	if (*p>>12 == 0x9)
	{
		if ((UBYTE)*p >= 0x40 AND (UBYTE)*p <= 0x47) // SUB.W dx,dx
		{
			if ((d_reg = GetReg2Even (*p)) != -1)
			{
				if ((a_reg = GetReg4Low (*p)) != -1)
				{
					MakeCode (Code, C_SUB, C_W);
					sprintf (Code1, Formats[44], D_reg[a_reg], D_reg[d_reg]);
					return (2);
				}
			}
		}
	}

	// ***************************** MOVE.B ***********************************
	if (*p>>12 == 0x1)
	{
		MakeCode (Code, C_MOVE, C_B); 

		if ((UBYTE)*p == 0x7C)									// move.b	#$00,($0000,ax)
		{
			if ((a_reg = GetReg2Odd (*p)) != -1)
			{
				sprintf (Code1, Formats[15], (UBYTE)*p1, (UWORD)*p2, A_reg[a_reg]);
				return (6);
			}
		}
		else if ((UBYTE)*p >= 0x28 AND (UBYTE)*p <= 0x2f)	// move.b ($0000,ax),dx
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Even (*p)) != -1)
				{
					sprintf (Code1, Formats[33], *p1, A_reg[a_reg], D_reg[d_reg]);
					return (4);
				}
			}
		}
		else if ((UBYTE)*p >= 0x90 AND (UBYTE)*p <= 0x97)	// move.b (ax),(ax)
		{
			if ((a_reg = GetReg4Low (*p)) != -1)
			{
				if ((d_reg = GetReg2Even (*p)) != -1)
				{
					sprintf (Code1, "(%s),(%s)", A_reg[a_reg], A_reg[d_reg]);
					return (2);
				}
			}
		}
		else if ((UBYTE)*p >= 0x98 AND (UBYTE)*p <= 0x9f)	// move.b	(ax)+,(ax)
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Even (*p)) != -1)
				{
					sprintf (Code1, "(%s)+,(%s)", A_reg[a_reg], A_reg[d_reg]);
					return (2);
				}
			}
		}
		else if ((UBYTE)*p >= 0xd8 AND (UBYTE)*p <= 0xdf)	// move.b	(ax)+,(ax)+
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Even (*p)) != -1)
				{
					sprintf (Code1, "(%s)+,(%s)+", A_reg[a_reg], A_reg[d_reg]);
					return (2);
				}
			}
		}
		else if ((UBYTE)*p >= 0x18 AND (UBYTE)*p <= 0x1f)	// move.b	(ax)+,dx
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Even (*p)) != -1)
				{
					sprintf (Code1, Formats[42], A_reg[a_reg], D_reg[d_reg]);
					return (2);
				}
			}
		}
		else if ((UBYTE)*p >= 0x00 AND (UBYTE)*p <= 0x07)	// move.b	dx,dx
		{
			if ((a_reg = GetReg4Low (*p)) != -1)
			{
				if ((d_reg = GetReg2Even (*p)) != -1)
				{
					sprintf (Code1, Formats[44], D_reg[a_reg], D_reg[d_reg]);
					return (2);
				}
			}
		}
		else if ((UBYTE)*p >= 0x10 AND (UBYTE)*p <= 0x17)	// move.b	(ax),dx
		{
			if ((d_reg = GetReg2Even (*p)) != -1)
			{
				if ((a_reg = GetReg4Low (*p)) != -1)
				{
					sprintf (Code1, Formats[34], A_reg[a_reg], D_reg[d_reg]);
					return (2);
				}
			}
		}
	}
	// ***************************** MOVE.W ***********************************
	if (*p>>12 == 0x3)
	{
		MakeCode (Code, C_MOVE, C_W); 

		if ((UBYTE)*p == 0x3c)						// move.w #$xxxx,dx ?
		{
			d_reg = *p;
			d_reg -= 0x3000;
			d_reg = d_reg>>8;
			if (!(d_reg % 2))	// only 0,2,4 etc
			{
				d_reg /= 2;
				if (d_reg < 8)
				{
					p++;
					sprintf (Code1, Formats[22], *p, D_reg[d_reg]);
					return (4);
				}
			}
		}
		else if ((UBYTE)*p >= 0x40 AND (UBYTE)*p <= 0x47)		// MOVE.W dx,($0000,ax)
		{
			if ((a_reg = GetReg2Odd (*p)) != -1)
			{
				if ((d_reg = GetReg4Low (*p)) != -1)
				{
					sprintf (Code1, Formats[45], D_reg[d_reg], *p1, A_reg[a_reg]);
					return (4);
				}
			}
		}
		else if ((UBYTE)*p >= 0x28 AND (UBYTE)*p <= 0x2f)	// move.w ($0000,ax),dx
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Even (*p)) != -1)
				{
					sprintf (Code1, Formats[33], *p1, A_reg[a_reg], D_reg[d_reg]);
					return (4);
				}
			}
		}
		else if ((UBYTE)*p >= 0x28 AND (UBYTE)*p <= 0x2f)	// move.w ($0000,ax),dx
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Even (*p)) != -1)
				{
					sprintf (Code1, Formats[33], *p1, A_reg[a_reg], D_reg[d_reg]);
					return (4);
				}
			}
		}
		else if ((UBYTE)*p >= 0x18 AND (UBYTE)*p <= 0x1f)			// MOVE.W (Ax)+,Dx
		{
			d_reg = *p;
			d_reg -= 0x3000;
			d_reg = d_reg>>8;
			if (!(d_reg % 2))	// only 0,2,4 etc
			{
				d_reg /= 2;
				if (d_reg < 8)
				{
					a_reg = (UBYTE)*p - 0x18;
					sprintf (Code1, Formats[42], A_reg[a_reg], D_reg[d_reg]);
					return (2);
				}
			}
		}
		else if ((UBYTE)*p >= 0x10 AND (UBYTE)*p <= 0x17) // MOVE.W (ax),dx
		{
			if ((d_reg = GetReg2Even (*p)) != -1)
			{
				if ((a_reg = GetReg4Low (*p)) != -1)
				{
					sprintf (Code1, Formats[34], A_reg[a_reg], D_reg[d_reg]);
					return (2);
				}
			}
		}
		else if ((UBYTE)*p >= 0x00 AND (UBYTE)*p <= 0x07) // MOVE.W dx,dx
		{
			if ((d_reg = GetReg2Even (*p)) != -1)
			{
				if ((a_reg = GetReg4Low (*p)) != -1)
				{
					sprintf (Code1, Formats[44], D_reg[a_reg], D_reg[d_reg]);
					return (2);
				}
			}
			else if ((a_reg = GetReg2Odd (*p)) != -1)				// MOVE.W dx,-(ax)
			{
				if ((d_reg = GetReg4Low (*p)) != -1)
				{
					sprintf (Code1, Formats[43], D_reg[d_reg], A_reg[a_reg]);
					return (2);
				}
			}
		}
	}

	// ***************************** MOVE.L ***********************************
	if (*p>>12 == 0x2)
	{
		MakeCode (Code, C_MOVE, C_L);

		if (*p>>8 == 0x23)
		{
			if ((UBYTE)*p >= 0xc0 AND (UBYTE)*p <= 0xcf)
			{
				if ((d_reg = GetReg4Low (*p)) != -1)						// move.l	d0,$xxxxxxxx
				{
					sprintf (Code1, Formats[7], D_reg[d_reg], *p2);
					return (6);
				}
				else if ((a_reg = GetReg4High (*p)) != -1)			// move.l	a0,$xxxxxxxx
				{
					sprintf (Code1, Formats[7], A_reg[a_reg], *p2);
					return (6);
				}
			}
			else if ((UBYTE)*p >= 0xd0 AND (UBYTE)*p <= 0xdf)
			{
				if ((a_reg = GetReg4Low (*p)) != -1)						// move.l	(a0),$xxxxxxxx
				{
					sprintf (Code1, Formats[8], A_reg[a_reg], *p2);
					return (6);
				}
				else if ((a_reg = GetReg4High (*p)) != -1)			// move.l	(a0)+,$xxxxxxxx
				{
					sprintf (Code1, Formats[9], A_reg[a_reg], *p2);
					return (6);
				}
			}
			else if ((UBYTE)*p >= 0xe0 AND (UBYTE)*p <= 0xe7)
			{
				if ((a_reg = GetReg4Low (*p)) != -1)						// move.l	-(a0),$xxxxxxxx
				{
					sprintf (Code1, Formats[10], A_reg[a_reg], *p2);
					return (6);
				}
			}
		}
		else if ((UBYTE)*p >= 0xc0 AND (UBYTE)*p <= 0xc7)	// move.l	dx,(ax)+
		{
			if ((a_reg = GetReg2Even (*p)) != -1)
			{
				if ((d_reg = GetReg4Low (*p)) != -1)
				{
					sprintf (Code1, Formats[52], D_reg[d_reg], A_reg[a_reg]);
					return (2);
				}
			}
		}
		else if ((UBYTE)*p >= 0x80 AND (UBYTE)*p <= 0x87)	// move.l	dx,(ax)
		{
			if ((a_reg = GetReg2Even (*p)) != -1)
			{
				if ((d_reg = GetReg4Low (*p)) != -1)
				{
					sprintf (Code1, Formats[35], D_reg[d_reg], A_reg[a_reg]);
					return (2);
				}
			}
		}
		else if ((UBYTE)*p == 0x7c)							// move.l #$xxxxxxx,($xxxx,ax)
		{
			if ((a_reg = GetReg2Odd (*p)) != -1)
			{
				if (value = CheckNeg_w (*p3))	// Neg?
					sprintf (Code1, Formats[4], *p2, value, A_reg[a_reg]);
				else
					sprintf (Code1, Formats[5], *p2, *p3, A_reg[a_reg]);
				return (8);
			}
		}
		else if ((UBYTE)*p == 0x3a)							// move.l ($xxxxxxx,PC),dx
		{
			if ((d_reg = GetReg2Even (*p)) != -1)
			{
				sprintf (Code1, Formats[47], address + (WORD)*p1 + 2, D_reg[d_reg]);
				return (4);
			}
			else if ((a_reg = GetReg2Odd (*p)) != -1)	// move.l ($xxxxxxx,PC),-(ax)
			{
				sprintf (Code1, Formats[20], address + (WORD)*p1 + 2, A_reg[a_reg]);
				return (4);
			}
		}
		else if ((UBYTE)*p >= 0x68 AND (UBYTE)*p <= 0x6f)	// move.l	($xxxx,ax),($xxxx,ax)
		{
			if ((d_reg = GetReg2Odd (*p)) != -1)
			{
				if ((a_reg = GetReg4High (*p)) != -1)
				{
					sprintf (Code1, Formats[50], *p1, A_reg[a_reg], (UWORD)*p2, A_reg[d_reg]);
					return (6);
				}
			}
		}
		else if ((UBYTE)*p == 0x3c)			// move.l #$xxxxxxx,dx ?
		{
			d_reg = *p;
			d_reg -= 0x2000;
			d_reg = d_reg>>8;
			if (!(d_reg % 2))	// only 0,2,4 etc
			{
				d_reg /= 2;
				if (d_reg < 8)
				{
					sprintf (Code1, Formats[6], *p2, D_reg[d_reg]);
					return (6);
				}
			}
		}
		else if ((UBYTE)*p == 0x39)
		{
			if ((a_reg = GetReg2Odd (*p)) != -1)				// MOVE.L $00000000,-(ax)
			{
				sprintf (Code1, Formats[16], *p2, A_reg[a_reg]);
				return (6);
			}
			else if ((d_reg = GetReg2Even (*p)) != -1)	// MOVE.L $00000000,dx
			{
				sprintf (Code1, Formats[11], *p2, D_reg[d_reg]);
				return (6);
			}
		}
		else if ((UBYTE)*p == 0x3a)	// MOVE.L ($00000000,pc),-(ax)
		{
			if ((a_reg = GetReg2Odd (*p)) != -1)
			{
				sprintf (Code1, Formats[20], address + (WORD)*p1 + 2, A_reg[a_reg]);
				return (4);
			}
		}
		else if ((UBYTE)*p >= 0x48 AND (UBYTE)*p <= 0x4f)	// MOVE.L ax,($0000,ax)
		{
			if ((a_reg = GetReg2Odd (*p)) != -1)
			{
				d_reg = (UBYTE)*p - 0x48;
				sprintf (Code1, Formats[45], A_reg[d_reg], *p1, A_reg[a_reg]);
				return (4);
			}
		}
		else if ((UBYTE)*p >= 0x40 AND (UBYTE)*p <= 0x47) 	// MOVE.L dx,($0000,ax)
		{
			if ((a_reg = GetReg2Odd (*p)) != -1)
			{
				d_reg = (UBYTE)*p - 0x40;
				sprintf (Code1, Formats[45], D_reg[d_reg], *p1, A_reg[a_reg]);
				return (4);
			}
		}
		else if ((UBYTE)*p >= 0x28 AND (UBYTE)*p <= 0x2f)	// move.l ($0000,ax),dx
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Even (*p)) != -1)
				{
					sprintf (Code1, Formats[33], *p1, A_reg[a_reg], D_reg[d_reg]);
					return (4);
				}
			}
		}
		else if ((UBYTE)*p >= 0x88 AND (UBYTE)*p <= 0x8f)	// move.l	ax,(ax)
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Even (*p)) != -1)
				{
					sprintf (Code1, Formats[35], A_reg[a_reg], A_reg[d_reg]);
					return (2);
				}
			}
		}
		else if ((UBYTE)*p >= 0x00 AND (UBYTE)*p <= 0x07) // MOVE.L Dx,Dx
		{
			d_reg = *p;
			d_reg -= 0x2000;
			d_reg = d_reg>>8;
			if (!(d_reg % 2))	// only 0,2,4 etc
			{
				d_reg /= 2;
				if (d_reg < 8)
				{
					a_reg = (UBYTE)*p;
					sprintf (Code1, Formats[44], D_reg[a_reg], D_reg[d_reg]);
					return (2);
				}
			}
		}
		else if ((UBYTE)*p >= 0x10 AND (UBYTE)*p <= 0x17) // MOVE.L (ax),Dx
		{
			if ((d_reg = GetReg2Even (*p)) != -1)
			{
				if ((a_reg = GetReg4Low (*p)) != -1)
				{
					sprintf (Code1, Formats[34], A_reg[a_reg], D_reg[d_reg]);
					return (2);
				}
			}
		}
		else if ((UBYTE)*p >= 0x08 AND (UBYTE)*p <= 0x0f)	// MOVE.L ax,dx
		{
			d_reg = *p;
			d_reg -= 0x2000;
			d_reg = d_reg>>8;
			if (!(d_reg % 2))	// only 0,2,4 etc
			{
				d_reg /= 2;
				if (d_reg < 8)
				{
					a_reg = (UBYTE)*p;
					a_reg -= 8;
					sprintf (Code1, Formats[44], A_reg[a_reg], D_reg[d_reg]);
					return (2);
				}
			}
		}
	}

	// ***************************** MOVEA.W **********************************
	if (*p>>12 == 0x3)
	{
		MakeCode (Code, C_MOVE, C_A1|C_W);

		if ((UBYTE)*p >= 0x40 AND (UBYTE)*p <= 0x47)			// movea.w dx,ax
		{
			if ((a_reg = GetReg2Even (*p)) != -1)
			{
				d_reg = (UBYTE)*p - 0x40;
				sprintf (Code1, Formats[44], D_reg[d_reg], A_reg[a_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0x68 AND (UBYTE)*p <= 0x6f)	// movea.w ($0000,ax),dx
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Even (*p)) != -1)
				{
					sprintf (Code1, Formats[33], *p1, A_reg[a_reg], D_reg[d_reg]);
					return (4);
				}
			}
		}
		else if ((UBYTE)*p == 0x7c)												// movea.w	#$xxxx,ax
		{
			if ((a_reg = GetReg2Even (*p)) != -1)
			{
				sprintf (Code1, Formats[18], *p1, A_reg[a_reg]);
				return (4);
			}
		}
	}

	// ***************************** MOVEA.L **********************************
	if (*p>>12 == 0x2)
	{
		MakeCode (Code, C_MOVE, C_A1|C_L);

		if ((UBYTE)*p == 0x79)	// movea.l	4,ax
		{
			if ((a_reg = GetReg2Even (*p)) != -1)
			{
				sprintf (Code1, Formats[11], *p2, A_reg[a_reg]);
				return (6);
			}
		}
		else if ((UBYTE)*p == 0x7a)	// movea.l	($xxxxxxxx,pc),ax
		{
			if ((a_reg = GetReg2Even (*p)) != -1)
			{
				sprintf (Code1, "($%08lX,PC),%s", address + (WORD)*p1 + 2, A_reg[a_reg]);
				return (4);
			}
		}
		else if ((UBYTE)*p >= 0x50 AND (UBYTE)*p <= 0x57)	// movea.l	(ax),ax
		{
			if ((a_reg = GetReg4Low (*p)) != -1)
			{
				if ((d_reg = GetReg2Even (*p)) != -1)
				{
					sprintf (Code1, Formats[34], A_reg[a_reg], A_reg[d_reg]);
					return (2);
				}
			}
		}
		else if ((UBYTE)*p >= 0x50 AND (UBYTE)*p <= 0x57)	// movea.l	(ax),ax
		{
			if ((a_reg = GetReg4Low (*p)) != -1)
			{
				if ((d_reg = GetReg2Even (*p)) != -1)
				{
					sprintf (Code1, Formats[34], A_reg[a_reg], A_reg[d_reg]);
					return (2);
				}
			}
		}
		else if ((UBYTE)*p >= 0x68 AND (UBYTE)*p <= 0x6F) 	// MOVEA.L ($0000,ax),ax
		{
			if ((a_reg = GetReg2Even (*p)) != -1)
			{
				d_reg = (UBYTE)*p - 0x68;
				sprintf (Code1, Formats[33], *p1, A_reg[d_reg], A_reg[a_reg]);
				return (4);
			}
		}
		else if ((UBYTE)*p >= 0x68 AND (UBYTE)*p <= 0x6f)	// movea.l ($0000,ax),dx
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Even (*p)) != -1)
				{
					sprintf (Code1, Formats[33], *p1, A_reg[a_reg], D_reg[d_reg]);
					return (4);
				}
			}
		}
		else if ((UBYTE)*p == 0x78)							// movea.l	0000.w,ax
		{
			if ((a_reg = GetReg2Even (*p)) != -1)
			{
				sprintf (Code1, Formats[19], *p1, W, A_reg[a_reg]);
				return (4);
			}
		}
		else if ((UBYTE)*p >= 0x40 AND (UBYTE)*p <= 0x47)	// MOVEA.L dx,ax
		{
			if ((a_reg = GetReg2Even (*p)) != -1)
			{
				d_reg = (UBYTE)*p - 0x40;
				sprintf (Code1, Formats[44], D_reg[d_reg], A_reg[a_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0x48 AND (UBYTE)*p <= 0x4f)	// MOVEA.L ax,ax
		{
			if ((a_reg = GetReg2Even (*p)) != -1)
			{
				d_reg = (UBYTE)*p - 0x48;
				sprintf (Code1, Formats[44], A_reg[d_reg], A_reg[a_reg]);
				return (2);
			}
		}
		else if ((UBYTE)*p >= 0x00 AND (UBYTE)*p <= 0x0f) // MOVEA.L ax/dx,-(sp)
		{
			BYTE reg;

			if ((reg = GetReg2Odd (*p)) != -1)
			{
				a_reg = reg;

				if ((reg = GetReg4Low (*p)) != -1)
				{
					sprintf (Code1, Formats[43], D_reg[reg], A_reg[a_reg]);
					return (2);
				}
				else
				{
					if ((reg = GetReg4High (*p)) != -1)
					{
						sprintf (Code1, Formats[43], A_reg[reg], A_reg[a_reg]);
						return (2);
					}
				}
			}
		}
		else if ((UBYTE)*p >= 0x10 AND (UBYTE)*p <= 0x1f)	// MOVEA.L (sp)+,dx
		{
			if ((d_reg = GetReg2Even (*p)) != -1)
			{
				if ((a_reg = GetReg4High (*p)) != -1)
				{
					sprintf (Code1, Formats[42], A_reg[a_reg], D_reg[d_reg]);
					return (2);
				}
			}
		}
		else if ((UBYTE)*p >= 0x50 AND (UBYTE)*p <= 0x5f) 	// MOVEA.L (sp)+,ax
		{
			if ((d_reg = GetReg2Even (*p)) != -1)
			{
				if ((a_reg = GetReg4High (*p)) != -1)
				{
					sprintf (Code1, Formats[42], A_reg[a_reg], A_reg[d_reg]);
					return (2);
				}
			}
		}
	}

	if (*p>>12 == 0x5)	// SUBQ.W	#1-8,dx/ax
	{
		if ((UBYTE)*p >= 0x40 AND (UBYTE)*p <= 0x4F)	// d0-d7/a0-a7
		{
			UWORD val;

			val = *p;
			val -= 0x5000;
			val = val>>8;
			if (val % 2)	// only 1,3,5 etc
			{
				MakeCode (Code, C_SUB, C_Q1|C_W);
				switch (val)
				{
					case 0x1: val = 8; break;
					case 0x3: val = 1; break;
					case 0x5: val = 2; break;
					case 0x7: val = 3; break;
					case 0x9: val = 4; break;
					case 0xB: val = 5; break;
					case 0xD: val = 6; break;
					case 0xF: val = 7; break;
				}
				reg = (UBYTE)*p - 0x40;
				if (reg >= 8)	// a0 - a7
					sprintf (Code1, Formats[38], val, A_reg[reg-8]);
				else
					sprintf (Code1, Formats[38], val, D_reg[reg]);
				return (2);
			}
		}
	}

	if (*p>>12 == 0xd)	// ADDX.L	-(ax),-(ax)
	{
		if ((UBYTE)*p >= 0x88 AND (UBYTE)*p <= 0x8f) 
		{
			if ((a_reg = GetReg4High (*p)) != -1)
			{
				if ((d_reg = GetReg2Odd (*p)) != -1)
				{
					MakeCode (Code, C_ADD, C_X1|C_L);
					sprintf (Code1, Formats[51], A_reg[a_reg], A_reg[d_reg]);
					return (2);
				}
			}
		}
	}

	if (*p>>12 == 0x5)	// ADDQ.W	#1-8,dx/ax
	{
		if ((UBYTE)*p >= 0x40 AND (UBYTE)*p <= 0x4F)	// d0-d7/a0-a7
		{
			UWORD val;

			if ((val = GetReg2Even (*p)) != -1)
			{
				MakeCode (Code, C_ADD, C_Q1|C_W);

				if (val == 0)
					val = 8;
				reg = (UBYTE)*p - 0x40;
				if (reg >= 8)	// a0 - a7
					sprintf (Code1, Formats[38], val, A_reg[reg-8]);
				else
					sprintf (Code1, Formats[38], val, D_reg[reg]);
				return (2);
			}
		}
		if ((UBYTE)*p >= 0x28 AND (UBYTE)*p <= 0x2f)	// addq.b	#x,($0000,ax)
		{
			UWORD val;

			if ((val = GetReg2Even (*p)) != -1)
			{
				if (val == 0)
					val = 8;
				if ((a_reg = GetReg4High (*p)) != -1)
				{
					MakeCode (Code, C_ADD, C_Q1|C_B);
					if (value = CheckNeg_w (*p1))	// Neg?
						sprintf (Code1, Formats[48], val, value, A_reg[a_reg]);
					else
						sprintf (Code1, Formats[49], val, *p1, A_reg[a_reg]);
					return (4);
				}
			}
		}
		else if ((UBYTE)*p >= 0x68 AND (UBYTE)*p <= 0x6f)	// add/subq.w	#x,($0000,ax)
		{
			UWORD val;

			if ((val = GetReg2Even (*p)) != -1)	// addq
				MakeCode (Code, C_ADD, C_Q1|C_W);
			else if ((val = GetReg2Odd (*p)) != -1)	// subq
				MakeCode (Code, C_SUB, C_Q1|C_W);
	
			if (val != -1)
			{
				if (val == 0)
					val = 8;
				if ((a_reg = GetReg4High (*p)) != -1)
				{
					if (value = CheckNeg_w (*p1))	// Neg?
						sprintf (Code1, Formats[48], val, value, A_reg[a_reg]);
					else
						sprintf (Code1, Formats[49], val, *p1, A_reg[a_reg]);
					return (4);
				}
			}
		}
	}

	if (*p>>12 == 0x5)	// SUBQ.L	#1-8,dx/ax
	{
		if ((UBYTE)*p >= 0x80 AND (UBYTE)*p <= 0x8F)	// d0-d7/a0-a7
		{
			UWORD val;

			val = *p;
			val -= 0x5000;
			val = val>>8;
			if (val % 2)	// only 1,3,5 etc
			{
				MakeCode (Code, C_SUB, C_Q1|C_L);
				switch (val)
				{
					case 0x1: val = 8; break;
					case 0x3: val = 1; break;
					case 0x5: val = 2; break;
					case 0x7: val = 3; break;
					case 0x9: val = 4; break;
					case 0xB: val = 5; break;
					case 0xD: val = 6; break;
					case 0xF: val = 7; break;
				}
				reg = (UBYTE)*p - 0x80;
				if (reg >= 8)	// a0 - a7
					sprintf (Code1, Formats[38], val, A_reg[reg-8]);
				else
					sprintf (Code1, Formats[38], val, D_reg[reg]);
				return (2);
			}
		}
	}
	if (*p>>12 == 0x5)	// ADDQ/SUBQ
	{
		UWORD val;

		if ((UBYTE)*p == 0x79)					// add/subq.w #x.$xxxxxxxx
		{
			if ((val = GetReg2Even (*p)) != -1)	// add
			{
				MakeCode (Code, C_ADD, C_Q1|C_W);
				if (val == 0)
					val = 8;
				sprintf (Code1, Formats[54], val, *p2);
				return (6);
			}
			else if ((val = GetReg2Odd (*p)) != -1)	// add
			{
				MakeCode (Code, C_SUB, C_Q1|C_W);
				if (val == 0)
					val = 8;
				sprintf (Code1, Formats[54], val, *p2);
				return (6);
			}
		}
		MakeCode (Code, C_ADD, C_Q1|C_L);
		if ((UBYTE)*p >= 0x80 AND (UBYTE)*p <= 0x87)	// addq.l
		{
			if ((val = GetReg2Even (*p)) != -1)
			{
				if (val == 0)
					val = 8;
				if ((d_reg = GetReg4Low (*p)) != -1)
				{
					sprintf (Code1, Formats[38], val, D_reg[d_reg]);
					return (2);
				}
			}
		}
		else if ((UBYTE)*p >= 0x88 AND (UBYTE)*p <= 0x8f)	// ax
		{
			if ((val = GetReg2Even (*p)) != -1)
			{
				if (val == 0)
					val = 8;
				if ((a_reg = GetReg4High (*p)) != -1)
				{
					sprintf (Code1, Formats[38], val, A_reg[a_reg]);
					return (2);
				}
			}
		}
		else if ((UBYTE)*p >= 0x90 AND (UBYTE)*p <= 0x97)	// (ax)
		{
			if ((val = GetReg2Even (*p)) != -1)
			{
				if (val == 0)
					val = 8;
				if ((a_reg = GetReg4Low (*p)) != -1)
				{
					sprintf (Code1, "#%ld,(%s)", val, A_reg[a_reg]);
					return (2);
				}
			}
		}
	}

	if (*p>>8 == 0x48)	// SWAP	dx
	{
		if ((UBYTE)*p >= 0x40 AND (UBYTE)*p <= 0x47)	// d0-d7
		{
			MakeCode (Code, C_SWAP, 0);

			d_reg = (UBYTE)*p - 0x40;
			sprintf (Code1, Formats[0], D_reg[d_reg]);
			return (2);
		}
	}
	if (*p>>8 == 0x42)	// MOVE	CCR,dx
	{
		if ((UBYTE)*p >= 0xC0 AND (UBYTE)*p <= 0xC7)	// d0-d7
		{
			MakeCode (Code, C_MOVE, 0);

			d_reg = (UBYTE)*p - 0xC0;
			sprintf (Code1, Formats[39], D_reg[d_reg]);
			return (2);
		}
	}
	if (*p>>8 == 0x42)	// MOVE	CCR,ax
	{
		if ((UBYTE)*p >= 0xD0 AND (UBYTE)*p <= 0xD7)	// a0-a7
		{
			MakeCode (Code, C_MOVE, 0);

			a_reg = (UBYTE)*p - 0xD0;
			sprintf (Code1, Formats[39], A_reg[a_reg]);
			return (2);
		}
	}
	if (*p>>8 == 0x42)	// MOVE	CCR,(ax)+
	{
		if ((UBYTE)*p >= 0xD8 AND (UBYTE)*p <= 0xDF)	// a0-a7
		{
			MakeCode (Code, C_MOVE, 0);

			a_reg = (UBYTE)*p - 0xD8;
			sprintf (Code1, Formats[40], A_reg[a_reg]);
			return (2);
		}
	}

	if (*p>>8 == 0x42)	// MOVE	CCR,-(ax)
	{
		if ((UBYTE)*p >= 0xE0 AND (UBYTE)*p <= 0xE7)	// a0-a7
		{
			MakeCode (Code, C_MOVE, 0);

			a_reg = (UBYTE)*p - 0xE0;
			sprintf (Code1, Formats[41], A_reg[a_reg]);
			return (2);
		}
	}

	if (*p>>8 == 0x51)
	{
		if ((UBYTE)*p >= 0xc8 AND (UBYTE)*p <= 0xcf)	// dbf dx,$xxxx
		{
			if ((d_reg = GetReg4High (*p)) != -1)
			{
				MakeCode (Code, C_DBF, 0);
				sprintf (Code1, "%s,$%08lX", D_reg[d_reg], address + (WORD)*p1 + 2);
				return (4);
			}
		}
	}

	if (*p == 0x51fc)
	{
		MakeCode (Code, C_TRAPF, 0);
		return (2);
	}

	return (0);
}

#define CODE_OFF 28

VOID OutPutAddress (ULONG address, BOOL mode)
{
	UWORD y, i, j;
	char Hold[200];
	char Hex[100];
	char Ascii[30];
	UBYTE *p, temp;

	y = 31;

	if (mode == 0)	// HEX
	{
		for (j = 0; j < 16; j++)
		{
			address = CheckMemAddress (address);
			sprintf (Hex, "$%08lX: ", address);
			Ascii[0] = 0;
	
			for (i = 0; i < 16; i++)
			{
				address = CheckMemAddress (address);

				p = (UBYTE *)address;
				sprintf (Hold, "%02lX ", *p);
				strcat (Hex, Hold);
	
		    if ((*p >= 32 AND *p <= 127) OR (*p >= 161 AND *p <= 255))
 			    temp = *p;
   			else
      		temp = '.';

				sprintf (Hold, "%c", temp);
				strcat (Ascii, Hold);
				address++;
			}
			sprintf (Hold, "%s%s", Hex, Ascii);
			JEOWrite (mm_rp, MM_X, y, Hold, 1);
			y += 8;
		}
	}
	else if (mode == 1)	// ASCII
	{
		for (j = 0; j < 16; j++)
		{
			address = CheckMemAddress (address);
			sprintf (Hex, "$%08lX: ", address);
			Ascii[0] = 0;
	
			for (i = 0; i < 64; i++)
			{
				address = CheckMemAddress (address);
	
				p = (UBYTE *)address;

		    if ((*p >= 32 AND *p <= 127) OR (*p >= 161 AND *p <= 255))
 			    temp = *p;
   			else
      		temp = '.';

				sprintf (Hold, "%c", temp);
				strcat (Hex, Hold);
				address++;
			}
			sprintf (Hold, Formats[0], Hex);
			JEOWrite (mm_rp, MM_X, y, Hold, 1);
			y += 8;
		}
	}
	else if (mode == 2)	// Disassemble
	{
		UWORD *p;
		UBYTE *pb;
		UBYTE nr;
		char Code[50] = "";
		char Code1[50] = "";
		char CPU[10] = "";
		UBYTE k;
		UBYTE offset;

		line_nr = 2;
		page_nr = 0;
		for (j = 0; j < 16; j++)
		{
			address = CheckMemAddress (address);
			sprintf (Hex, "$%08lX: %64s", address, "");
			Ascii[0] = 0;
	
			for (i = 0; i < 16; i++)
			{
				address = CheckMemAddress (address);
	
				p = (UWORD *)address;

				offset = 11;
				Code1[0] = CPU[0] = 0;
				if (nr = FindCode ((ULONG)p, Code, Code1, CPU))
				{
					for (k = 0; k < nr; k++)
					{
						pb = (UBYTE *)address;
						sprintf (Hold, "%02lX", *pb);
						CopyMem (Hold, &Hex[offset], strlen (Hold));
						offset += 2;
						address++;
					}
					page_nr += nr;
					if (j == 0 AND i == 0)
						line_nr = nr;
					CopyMem (Code, &Hex[CODE_OFF], strlen (Code));
					if (*Code1)
						CopyMem (Code1, &Hex[CODE_OFF+9], strlen (Code1));
					if (*CPU)
						CopyMem (CPU, &Hex[CODE_OFF+36], strlen (CPU));
					break;
				}
				else
				{
					sprintf (Hold, "%04lX", *p);
					CopyMem (Hold, &Hex[offset], strlen (Hold));
					CopyMem ("????", &Hex[CODE_OFF], 4);
					address += 2;
					page_nr += 2;
					break;
				}
			}
			sprintf (Hold, Formats[0], Hex);
			JEOWrite (mm_rp, MM_X, y, Hold, 1);
			y += 8;
		}
	}
}

BOOL monitorGadgetFlag;

VOID MonitorAll (BOOL status)
{
  if (status == P)
  {
    if (monitorGadgetFlag != P)
    {
      AddGList (MonitorWnd, MonitorGList, -1, -1, NULL);
      monitorGadgetFlag = P;
			ClearPointer (MonitorWnd);
    }
  }
  else	/* AV */
  {
    if (monitorGadgetFlag != AV)
    {
      RemoveGList (MonitorWnd, MonitorGList, -1);
			monitorGadgetFlag = AV;
			rtSetWaitPointer (MonitorWnd);
    }
  }
}

BOOL patchGadgetFlag;

VOID PatchAll (BOOL status)
{
  if (status == P)
  {
    if (patchGadgetFlag != P)
    {
      AddGList (PatchWnd, PatchGList, -1, -1, NULL);
      patchGadgetFlag = P;
			ClearPointer (PatchWnd);
    }
  }
  else	/* AV */
  {
    if (patchGadgetFlag != AV)
    {
      RemoveGList (PatchWnd, PatchGList, -1);
			patchGadgetFlag = AV;
			rtSetWaitPointer (PatchWnd);
    }
  }
}

VOID MemoryMonitor (ULONG address)
{
	ULONG	waitsigs;
	BOOL quit = 1;
	char Hold[100];
	char MemName[50] = "";

	if (address == 0)
		return;

	original_address = address;

	patchGadgetFlag = ON;	// Gadgets are ON!
	monitorGadgetFlag = ON;	// Gadgets are ON!
	PatchAll (OFF);

	dump = 0;	// Hex

	MonitorLeft = (VirusWnd->Width / 2) - (MonitorWidth / 2) + VirusWnd->LeftEdge;
	MonitorTop = VirusWnd->TopEdge + 48;
	if (!OpenMonitorWindow ())
	{
		SetWindowTitles (MonitorWnd, GLS (&L_MEMORY_MONITOR), Ver);
		mm_rp = MonitorWnd->RPort;		
		if (textfont)
			SetFont (mm_rp, textfont);

		FindMemoryAera (address, MemName);

		sprintf (Hold, GLS (&L_MEMORY_AREA), mem_start, mem_end, MemName);
		JEOWrite (mm_rp, MM_X, 13, Hold, 1);

		top_address = address;
		OutPutAddress (address, dump);	// Start with hex always

		waitsigs = (1L << MonitorWnd->UserPort->mp_SigBit);
		while (quit)
		{
			Wait (waitsigs);
			quit = HandleMonitorIDCMP ();
		}
		CloseMonitorWindow ();
	}

	PatchAll (ON);
	Status (GLS (&L_READY));
}
