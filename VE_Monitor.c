#define MONITORDEBUG 1

/*
 *  Source machine generated by GadToolsBox V2.0b
 *  which is (c) Copyright 1991-1993 Jaba Development
 *
 *  GUI Designed by : Jan Erik Olausen
 */

// 	oldFunc = SetFunction (library, funcOffset, funcEntry)
//     	D0		                A1       A0.W	       D0


#include <JEO:JEO.h>
#include <ctype.h>
#include <exec/memory.h>
#include <exec/execbase.h>
#include <proto/dos.h>
#include <proto/intuition.h>
#include <proto/graphics.h>
#include <proto/gadtools.h>
#include <libraries/reqtools.h>
#include <proto/reqtools.h>
#include "VE_Prototypes.h"
#include <JEO:raw.h>
#include "VE_Monitor.h"
#include <intuition/gadgetclass.h>
#include <proto/disassembler.h>
#include "PatchWindow.h"

VOID OutPutAddress (ULONG address, BOOL mode);
ULONG CheckMemAddress (ULONG address);
VOID MonitorAll (BOOL status);

struct DisassemblerBase *DisassemblerBase;
struct DisData *disData;

UBYTE line_nr, page_nr;
struct RastPort *mm_rp;

#define MM_X	12
BOOL dis_flag;

ULONG original_address, top_address;

struct Window         *MonitorWnd = NULL;
struct Gadget         *MonitorGList = NULL;
struct Gadget         *MonitorGadgets[7];
UWORD                  MonitorLeft = 0;
UWORD                  MonitorTop = 25;
UWORD                  MonitorWidth = 632;
UWORD                  MonitorHeight = 193;
UBYTE                 *MonitorWdt = NULL;

UBYTE *MM_DUMP0Labels[] = {
	(UBYTE *)"Hex dump",
	(UBYTE *)"ASCII dump",
	(UBYTE *)"Disassemble",
	NULL };

UWORD MonitorGTypes[] = {
	CYCLE_KIND,
	BUTTON_KIND,
	BUTTON_KIND,
	BUTTON_KIND,
	BUTTON_KIND,
	BUTTON_KIND,
	BUTTON_KIND
};

struct NewGadget MonitorNGad[] = {
	  3, 170, 114, 15, NULL, NULL, GD_MM_DUMP, 0, NULL, NULL,
	147, 170,  66, 15, (UBYTE *)"Line -", NULL, GD_MM_LINE_MINUS, PLACETEXT_IN, NULL, NULL,
	216, 170,  66, 15, (UBYTE *)"Line +", NULL, GD_MM_LINE_PLUS, PLACETEXT_IN, NULL, NULL,
	294, 170,  66, 15, (UBYTE *)"Page -", NULL, GD_MM_PAGE_MINUS, PLACETEXT_IN, NULL, NULL,
	363, 170,  66, 15, (UBYTE *)"Page +", NULL, GD_MM_PAGE_PLUS, PLACETEXT_IN, NULL, NULL,
	451, 170,  75, 15, (UBYTE *)"Home", NULL, GD_MM_ADDRESS, PLACETEXT_IN, NULL, NULL,
	548, 170,  66, 15, (UBYTE *)"Exit", NULL, GD_MM_EXIT, PLACETEXT_IN, NULL, NULL
};

ULONG MonitorGTags[] = {
	(GTCY_Labels), (ULONG)&MM_DUMP0Labels[ 0 ], (TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE)
};

void MonitorRender( void )
{
	UWORD		offx, offy;

	offx = MonitorWnd->BorderLeft;
	offy = Scr->WBorTop + Scr->RastPort.TxHeight + 1;

	DrawBevelBox( MonitorWnd->RPort, offx + 1, offy + 2, 612, 25, GT_VisualInfo, VisualInfo, GTBB_Recessed, TRUE, TAG_DONE );
	DrawBevelBox( MonitorWnd->RPort, offx + 2, offy + 31, 612, 134, GT_VisualInfo, VisualInfo, GTBB_Recessed, TRUE, TAG_DONE );
}

int OpenMonitorWindow( void )
{
	struct NewGadget	ng;
	struct Gadget	*g;
	UWORD		lc, tc;
	UWORD		offx = Scr->WBorLeft, offy = Scr->WBorTop + Scr->RastPort.TxHeight + 1;

	if ( ! ( g = CreateContext( &MonitorGList )))
		return( 1L );

	for( lc = 0, tc = 0; lc < Monitor_CNT; lc++ ) {

		CopyMem((char * )&MonitorNGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

		ng.ng_VisualInfo = VisualInfo;
		ng.ng_TextAttr   = &topaz8;
		ng.ng_LeftEdge  += offx;
		ng.ng_TopEdge   += offy;

		MonitorGadgets[ lc ] = g = CreateGadgetA((ULONG)MonitorGTypes[ lc ], g, &ng, ( struct TagItem * )&MonitorGTags[ tc ] );

		while( MonitorGTags[ tc ] ) tc += 2;
		tc++;

		if ( NOT g )
			return( 2L );
	}

	if ( ! ( MonitorWnd = OpenWindowTags( NULL,
				WA_Left,	MonitorLeft,
				WA_Top,		MonitorTop,
				WA_Width,	MonitorWidth,
				WA_Height,	MonitorHeight + offy,
				WA_IDCMP,	CYCLEIDCMP|BUTTONIDCMP|IDCMP_CLOSEWINDOW|IDCMP_ACTIVEWINDOW|IDCMP_REFRESHWINDOW|IDCMP_RAWKEY,
				WA_Flags,	WFLG_DRAGBAR|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH|WFLG_ACTIVATE|WFLG_RMBTRAP,
				WA_Gadgets,	MonitorGList,
				WA_CustomScreen, Scr,
				TAG_DONE )))
	return( 4L );

	GT_RefreshWindow( MonitorWnd, NULL );

	MonitorRender();

	return( 0L );
}

void CloseMonitorWindow( void )
{
	if ( MonitorWnd        ) {
		CloseWindow( MonitorWnd );
		MonitorWnd = NULL;
	}

	if ( MonitorGList      ) {
		FreeGadgets( MonitorGList );
		MonitorGList = NULL;
	}
}

// *****************************************************************************

ULONG mem_start, mem_end;

VOID LineDown (VOID)
{
	if (prefs->dump == 0)
	{
		top_address += 16;	// HEX
		if (top_address > mem_end)
			top_address = mem_start + (top_address - mem_end - 1);
	}
	else if (prefs->dump == 1)
	{
		top_address += 64;	// ASCII
		if (top_address > mem_end)
			top_address = mem_start + (top_address - mem_end - 1);
	}
	else if (prefs->dump == 2)
	{
		top_address += line_nr;	// Disassemble
		if (top_address > mem_end)
			top_address = mem_start + (top_address - mem_end - 1);
	}
	OutPutAddress (top_address, prefs->dump);	// Start with hex always
}

VOID LineUp (VOID)
{
	if (prefs->dump == 0)
	{
		top_address -= 16;	// HEX
		if (top_address < mem_start)
			top_address = mem_end - (mem_start - top_address - 1);
	}
	else if (prefs->dump == 1)
	{
		top_address -= 64;	// ASCII
		if (top_address < mem_start)
			top_address = mem_end - (mem_start - top_address - 1);
	}
	else if (prefs->dump == 2)
	{
		top_address -= 2;	// Disassemble
		if (top_address < mem_start)
			top_address = mem_end - (mem_start - top_address - 1);
	}
	OutPutAddress (top_address, prefs->dump);	// Start with hex always
}

VOID PageUp (VOID)
{
	if (prefs->dump == 0)
	{
		top_address -= (16 * 16);	// HEX
		if (top_address < mem_start)
			top_address = mem_end - (mem_start - top_address - 1);
	}
	else if (prefs->dump == 1)
	{
		top_address -= (16 * 64);	// ASCII
		if (top_address < mem_start)
			top_address = mem_end - (mem_start - top_address - 1);
	}
	else if (prefs->dump == 2)
	{
		top_address -= 32;	// Disassembler
		if (top_address < mem_start)
			top_address = mem_end - (mem_start - top_address - 1);
	}
	OutPutAddress (top_address, prefs->dump);	// Start with hex always
}

VOID PageDown (VOID)
{
	if (prefs->dump == 0)
	{
		top_address += (16 * 16);	// HEX
		if (top_address > mem_end)
			top_address = mem_start + (top_address - mem_end - 1);
	}
	else if (prefs->dump == 1)
	{
		top_address += (16 * 64);	// ASCII
		if (top_address > mem_end)
			top_address = mem_start + (top_address - mem_end - 1);
	}
	else if (prefs->dump == 2)
	{
		top_address += page_nr;	// Disassemble
		if (top_address > mem_end)
			top_address = mem_start + (top_address - mem_end - 1);
	}
	OutPutAddress (top_address, prefs->dump);	// Start with hex always
}

VOID Home (VOID)
{
	top_address = original_address;
	OutPutAddress (top_address, prefs->dump);

/*
	{
		ULONG address;
		char Buf[9];
	
		SPrintF (Buf, "%08lx", original_address);
		MonitorAll (OFF);
		if (rtGetString (Buf, 8, "Enter address:", NULL, RT_ReqPos, REQPOS_CENTERSCR, RT_TextAttr, &topaz8, TAG_END))
		{
			top_address = strtoul (Buf, NULL, 16);
			OutPutAddress (top_address, prefs->dump);	// Start with hex always
		}
		MonitorAll (ON);
	}
*/
}

VOID MonitorInitGadget (UWORD num, LONG tagtype, LONG tagvalue)
{
  GT_SetGadgetAttrs (MonitorGadgets[num], MonitorWnd, NULL, tagtype, tagvalue, TAG_DONE);
}

#if MONITORDEBUG 

BOOL stop_flag = FALSE;

VOID SearchSearchDirectory (char *Dir, UBYTE *Buf, UWORD nr)
{
	char Name[300];
  struct FileInfoBlock *fileinfoblock = 0;
  ULONG success;
  BPTR lock;

  fileinfoblock = (struct FileInfoBlock *) AllocMem (sizeof (struct FileInfoBlock), MEMF_CLEAR);

	if (lock = Lock (Dir, ACCESS_READ))
	{
 		if (success = Examine (lock, fileinfoblock))
		{
  		NameFromLock (lock, Name, 300);	// Vi finner dirnavnet!

			stop_flag = FALSE;
			FOREVER
			{
				success = ExNext (lock, fileinfoblock);	// FindNext File/Dir
			  if (!success)				// End of directory?
 		  	{
		  		UnLock (lock);
		  		lock = 0;
	  			break;
	 			}

 			  if (fileinfoblock->fib_DirEntryType < 0)	// A file?
 			  {
 			  	BPTR fh;
 			  	LONG size;
 			  	char *FileBuf;
 			  	ULONG *header;

				 	if ((Name[strlen (Name) - 1] != ':') AND (Name[strlen (Name) - 1] != '/'))
				  	strcat (Name, "/");
				  SPrintF (FullName, "%s%s", Name, fileinfoblock->fib_FileName);

					size = FileSize (FullName);
					if (size > 1)
					{
						if (FileBuf = AllocMem (size, MEMF_PUBLIC))
						{
							if (fh = Open (FullName, MODE_OLDFILE))
							{
								Read (fh, FileBuf, size);
								Close (fh);
							}
							header = (ULONG *)FileBuf;
							if ((*header == 0x000003F3) OR (!(stricmp (fileinfoblock->fib_FileName, "AmigaOS ROM Update"))))	// Exe file?
							{
								ULONG i;
								BOOL flag;

								char Hold[300];
								SPrintF (Hold, "(%ld) '%s'", nr * 2, FullName);
								Status (Hold);

								for (i = 0; i < size - (nr * 2); i++)
								{
									flag = FALSE;
									if (!(memcmp (&FileBuf[i], Buf, nr * 2)))
									{
										flag = TRUE;
										break;
									}
								}
								if (flag)
								{
									SPrintF (Hold, "Found in '%s'", FullName);
									if (!JEOSoundRequest (GLS (&L_MESSAGE), Hold, GLS (&L_CONTINUE_STOP), S_MESSAGE))
									{
										stop_flag = TRUE;
										break;
									}
								}
							}

							FreeMem (FileBuf, size);
						}
					}
				}
				if (stop_flag)
					break;
  		}
  	}
	}
	if (lock)
		UnLock (lock);
	FreeMem (fileinfoblock, sizeof (struct FileInfoBlock));
}

#define SEARCH_SIZE 100

VOID SearchPatch (VOID)
{
	UBYTE nr;
	UWORD *p;
	UWORD *Buf;

	if (Buf = AllocMem (SEARCH_SIZE, MEMF_PUBLIC))
	{
		p = (UWORD *)original_address;

		for (nr = 0; nr < 8; nr++)
		{
			Buf[nr] = *p;
			if (Buf[nr] == 0x4ef9)	// JMP
				break;
			if (Buf[nr] == 0x4e75)	// RTS
				break;
			if (Buf[nr] == 0x4e73)	// RTE
				break;

			if (Buf[nr] == 0x4eb9)	// JSR $xxxxxxxx
				break;

			// LEA $xxxxxx,ax
			if (Buf[nr] == 0x41F9 OR Buf[nr] == 0x43F9 OR Buf[nr] == 0x45F9 OR Buf[nr] == 0x47F9 OR Buf[nr] == 0x49F9 OR Buf[nr] == 0x4BF9 OR Buf[nr] == 0x4DF9 OR Buf[nr] == 0x4FF9)
				break;

			// MOVEA.L $xxxxxx,ax
			if (Buf[nr] == 0x2079 OR Buf[nr] == 0x2279 OR Buf[nr] == 0x2479 OR Buf[nr] == 0x2679 OR Buf[nr] == 0x2879 OR Buf[nr] == 0x2A79 OR Buf[nr] == 0x2C79 OR Buf[nr] == 0x2E79)
				break;

// *************** REMOVE ***************
			if (Buf[nr] == 0x00fb AND Buf[nr+1] == 0xe9bc)
				break;

			p++;
		}

		Buf[nr] = *p;
		nr++;

		SearchSearchDirectory ("c:", (UBYTE *)Buf, nr);
		if (!stop_flag)
			SearchSearchDirectory ("libs:", (UBYTE *)Buf, nr);
		if (!stop_flag)
			SearchSearchDirectory ("sys:wbstartup", (UBYTE *)Buf, nr);
		if (!stop_flag)
			SearchSearchDirectory ("devs:", (UBYTE *)Buf, nr);
		if (!stop_flag)
			SearchSearchDirectory ("devs:modules", (UBYTE *)Buf, nr);
		if (!stop_flag)
			SearchSearchDirectory ("l:", (UBYTE *)Buf, nr);

		Status (GLS (&L_READY));
		FreeMem (Buf, SEARCH_SIZE);
	}
}

#endif

BOOL HandleMonitorIDCMP (VOID)
{
	struct IntuiMessage	*m;
	struct IntuiMessage	tmpmsg;
  BOOL ret = TRUE;

	while (m = GT_GetIMsg (MonitorWnd->UserPort))
	{
		CopyMem ((char *)m, (char *)&tmpmsg, (long)sizeof(struct IntuiMessage));
		GT_ReplyIMsg (m);
		switch (tmpmsg.Class)
		{
/*
			case IDCMP_DISKINSERTED:
				DiskInserted ();
				All (OFF);
				Status (GLS (&L_PLEASE_WAIT));
				break;
			case IDCMP_DISKREMOVED:
				DiskRemoved ();
				Status (GLS (&L_PLEASE_WAIT));
				break;
*/
			case	IDCMP_RAWKEY:
			{
				switch (tmpmsg.Code)
				{
					case ESC: ret = FALSE; break;
#if MONITORDEBUG 
					case F10:
					{
						SearchPatch ();
						break;
					}
#endif
					case HELP:
					{
						prefs->address_mode_flag ^= 1;
						OutPutAddress (top_address, prefs->dump);
						break;
					}
					case DOWN_ARR:	LineDown ();	break;
					case UP_ARR:		LineUp ();		break;
					case RIGHT_ARR: PageDown ();	break;
					case LEFT_ARR:	PageUp ();		break;

					case NUMERIC2:	LineDown ();	break;
					case NUMERIC8:	LineUp ();		break;
					case NUMERIC3:	PageDown ();	break;
					case NUMERIC9:	PageUp ();		break;
					case NUMERIC7:	Home ();			break;
				}
				break;
			}
			case	IDCMP_CLOSEWINDOW:
			{
				ret = FALSE;
				break;
			}
			case	IDCMP_GADGETUP:
			{
			  struct Gadget *gadget;
				UWORD nr;

			  gadget = (struct Gadget *)tmpmsg.IAddress;
				nr = gadget->GadgetID;

			  switch (nr)
			  {
					case GD_MM_EXIT:
					{
						ret = FALSE;
						break;
					}
					case GD_MM_DUMP:
					{
						prefs->dump++;
						if (prefs->dump > 2)
							prefs->dump = 0;

						OutPutAddress (top_address, prefs->dump);	// Start with hex always
						break;
					}
					case GD_MM_LINE_MINUS: LineUp ();   break;
					case GD_MM_LINE_PLUS:  LineDown ();	break;
					case GD_MM_PAGE_MINUS: PageUp ();		break;
					case GD_MM_PAGE_PLUS:	 PageDown ();	break;
					case GD_MM_ADDRESS:		 Home (); break;
				}
				break;
			}
		}
	}
	return (ret);
}

VOID FindMemoryAera (ULONG address, char *MemName)
{
  struct Node *node;
  ULONG *end;

	Forbid ();
	node = SysBase->MemList.lh_Head;
	while (node->ln_Succ)
	{
		end = (ULONG *)node;
		end += 6;

		mem_start = (ULONG)node;
		mem_end = (ULONG)*end - 1;

		if (mem_start == 0x1000)	// chip?
			mem_start = 0;
		
		if ((address >= mem_start) AND (address <= mem_end))
		{
			if (node->ln_Name AND *node->ln_Name)
				strcpy (MemName, node->ln_Name);
			else
				strcpy (MemName, GLS (&L_NA));

 			break;
		}
		node = node->ln_Succ;
	}
	Permit ();
}

ULONG CheckMemAddress (ULONG address)
{
	if (address > mem_end)
		return (mem_start);
	else if (address < mem_start)
		return (mem_end);
	else
		return (address);
}

char MonHold[100];
UBYTE monCount = 0;

#define CODE_OFF 28

VOID DoOutput (char *To, char *From, char *Address)
{
	UBYTE i, j;

	memset (To, ' ', 75);

//	printf ("%s\n", From);
	if (!prefs->address_mode_flag)
	{
		Address[0] = '$';						// Address
		for (i = 1; i < 9; i++)
			Address[i] = From[i-1];
		Address[i] = ':';
		Address[i+1] = ' ';
		Address[i+2] = 0;
	}
	else
	{
		char Hold[10];
		ULONG add;

		for (i = 0; i < 8; i++)
			Hold[i] = From[i];
		Hold[i] = 0;

		add = strtoul (Hold, NULL, 16);
		SPrintF (Address, "%9ld: ", add - original_address);
	}

	for (i = 11, j = 0; i < 31; i++)	// Hex
	{
		if (From[i+1] == ' ')
			continue;
		else
		{
			To[j] = From[i+1];
			j++;
		}
	}

	for (i = 39, j = CODE_OFF-11; From[i] != 0; i++, j++)	// Code
	{
		To[j] = From[i];
		if (From[i] == ' ')
			break;
	}

	if (strncmp (&From[39], "???", 3))	// Unknown?
	{
		if (From[i] != 0)	// Args...
		{
			for (i = i+1, j = CODE_OFF + 9 - 11; From[i] != 0; i++)
			{
				To[j] = From[i];
				j++;
				if (From[i] == ' ')
					break;
			}
		}
	}

	To[75-11] = 0;
	JEOtoupper (To);
	JEOtoupper (Address);
}

__asm far VOID AsmOut (register __d0 UBYTE ch, register __a2 APTR data)
{
	if (ch == '\n')
		disData->ds_UpTo = data;	// Stop!
	MonHold[monCount++] = ch;
}

VOID OutPutAddress (ULONG address, BOOL mode)
{
	UWORD y, i, j;
	char Address[12];
	char Hold[200];
	char Hex[100];
	char Ascii[30];
	UBYTE *p, temp;

	y = Scr->WBorTop + Scr->RastPort.TxHeight + 41;

	if (FindSegAddress (address, Hold))
		Hold[53] = 0;	// Just in case
	else
		strcpy (Hold, N_A_Msg);
	SPrintF (Dummy, "%s: $%08lx %-53.53s", SEG_SEM, address, Hold);
	JEOWrite (mm_rp, MM_X, Scr->WBorTop + Scr->RastPort.TxHeight + 23, Dummy, 1);

	if (mode == 0)	// HEX
	{
		for (j = 0; j < 16; j++)
		{
			address = CheckMemAddress (address);

			if (!prefs->address_mode_flag)
				SPrintF (Address, "$%08lx: ", address);
			else
				SPrintF (Address, "%9ld: ", address - original_address);
			Ascii[0] = 0;
	
			Hex[0] = 0;
			for (i = 0; i < 16; i++)
			{
				address = CheckMemAddress (address);

				p = (UBYTE *)address;
				SPrintF (Hold, "%02lx ", *p);
				strcat (Hex, Hold);
	
		    if ((*p >= 32 AND *p <= 127) OR (*p >= 161 AND *p <= 255))
 			    temp = *p;
   			else
      		temp = '.';

				SPrintF (Hold, "%lc", temp);
				strcat (Ascii, Hold);
				address++;
			}
			JEOWrite (mm_rp, MM_X, y, Address, WHITE);
			SPrintF (Hold, "%s%s", Hex, Ascii);
			JEOWrite (mm_rp, MM_X + (11*8), y, Hold, BLACK);
			y += 8;
		}
	}
	else if (mode == 1)	// ASCII
	{
		for (j = 0; j < 16; j++)
		{
			address = CheckMemAddress (address);

			if (!prefs->address_mode_flag)
				SPrintF (Address, "$%08lx: ", address);
			else
				SPrintF (Address, "%9ld: ", address - original_address);
			Ascii[0] = 0;

			Hex[0] = 0;
			for (i = 0; i < 64; i++)
			{
				address = CheckMemAddress (address);
	
				p = (UBYTE *)address;

		    if ((*p >= 32 AND *p <= 127) OR (*p >= 161 AND *p <= 255))
 			    temp = *p;
   			else
      		temp = '.';

				SPrintF (Hold, "%lc", temp);
				strcat (Hex, Hold);
				address++;
			}

			JEOWrite (mm_rp, MM_X, y, Address, WHITE);
			JEOWrite (mm_rp, MM_X + (11*8), y, Hex, BLACK);
			y += 8;
		}
	}
	else if (mode == 2)	// Disassemble
	{
		APTR next;
		char Out[100];

		if (dis_flag)
		{
			page_nr = 0;
			address = CheckMemAddress (address);

			disData->ds_From = (APTR)address;
			disData->ds_UpTo = (APTR)(address + 10);
			disData->ds_PutProc = (VOID *)AsmOut;
			disData->ds_reserved = NULL;

			for (i = 0; i < 16; i++)
			{
				monCount = 0;
				next = Disassemble (disData);
				if (i == 0)
					line_nr = (ULONG)next - address;

				MonHold[monCount-1] = 0;
				disData->ds_From = (APTR)next;
				disData->ds_UpTo = (APTR)((ULONG)next + 10);
				DoOutput (Out, MonHold, Address);
				JEOWrite (mm_rp, MM_X, y, Address, WHITE);
				JEOWrite (mm_rp, MM_X + (11*8), y, Out, BLACK);
				y += 8;
			}
			page_nr = (ULONG)next - address;
		}
		else
		{
			memset (Out, ' ', 75);
			Out[75] = 0;
			for (i = 0; i < 16; i++, y += 8)
				JEOWrite (mm_rp, MM_X, y, Out, BLACK);

			y = Scr->WBorTop + Scr->RastPort.TxHeight + 41;
			SPrintF (Out, GLS (&L_VE_NEEDS_DIS_LIB), VE, DISASSEMBLER_NAME);
			Out[strlen (Out)] = ' ';
			for (i = 0; i < 16; i++, y += 8)
				JEOWrite (mm_rp, MM_X, y, Out, WHITE);
		}
	}
}

BOOL monitorGadgetFlag;

VOID MonitorAll (BOOL status)
{
  if (status == PÅ)
  {
    if (monitorGadgetFlag != PÅ)
    {
      AddGList (MonitorWnd, MonitorGList, -1, -1, NULL);
      monitorGadgetFlag = PÅ;
			ClearPointer (MonitorWnd);
    }
  }
  else	/* AV */
  {
    if (monitorGadgetFlag != AV)
    {
      RemoveGList (MonitorWnd, MonitorGList, -1);
			monitorGadgetFlag = AV;
			rtSetWaitPointer (MonitorWnd);
    }
  }
}

BOOL patchGadgetFlag;

VOID PatchAll (BOOL status)
{
  if (status == PÅ)
  {
    if (patchGadgetFlag != PÅ)
    {
      AddGList (PatchWnd, PatchGList, -1, -1, NULL);
      patchGadgetFlag = PÅ;
			ClearPointer (PatchWnd);
    }
  }
  else	/* AV */
  {
    if (patchGadgetFlag != AV)
    {
      RemoveGList (PatchWnd, PatchGList, -1);
			patchGadgetFlag = AV;
			rtSetWaitPointer (PatchWnd);
    }
  }
}

VOID MemoryMonitor (ULONG address, WORD off)
{
	ULONG	waitsigs;
	BOOL quit = 1;
	char Hold[100];
	char MemName[50] = "";

	if (address == 0)
		return;

	original_address = address;

	patchGadgetFlag = ON;	// Gadgets are ON!
	monitorGadgetFlag = ON;	// Gadgets are ON!
	PatchAll (OFF);

	dis_flag = TRUE;
	if (!(DisassemblerBase = (struct DisassemblerBase *)OpenLibrary (DISASSEMBLER_NAME, 0)))
		dis_flag = FALSE;
	if (!(disData = AllocMem (sizeof (struct DisData), MEMF_PUBLIC)))
		dis_flag = FALSE;
	
	MonitorLeft = (VirusWnd->Width / 2) - (MonitorWidth / 2) + VirusWnd->LeftEdge;
	MonitorTop = VirusWnd->TopEdge + 48;
	if (!OpenMonitorWindow ())
	{
		SetWindowTitles (MonitorWnd, GLS (&L_MEMORY_MONITOR), Ver);
		mm_rp = MonitorWnd->RPort;		
		if (textfont)
			SetFont (mm_rp, textfont);

		MonitorInitGadget (GD_MM_DUMP, GTCY_Active, prefs->dump);

		FindMemoryAera (address, MemName);

		SPrintF (Hold, GLS (&L_MEMORY_AREA), mem_start, mem_end, MemName);
		JEOWrite (mm_rp, MM_X, Scr->WBorTop + Scr->RastPort.TxHeight + 13, Hold, 1);

		top_address = address;
		OutPutAddress (address, prefs->dump);

		waitsigs = (1L << MonitorWnd->UserPort->mp_SigBit);
		while (quit)
		{
			Wait (waitsigs);
			quit = HandleMonitorIDCMP ();
		}
		CloseMonitorWindow ();
	}

	if (dis_flag)
	{
		if (DisassemblerBase)
			CloseLibrary ((struct Library *)DisassemblerBase);
		if (disData)
			FreeMem (disData, sizeof (struct DisData));
	}

	PatchAll (ON);
	Status (GLS (&L_READY));
}
